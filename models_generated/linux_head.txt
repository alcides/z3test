Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF8
01:08:36.521 [main] INFO  HeadREST - This is HeadREST version 0.1.1 running on specification Erro.rspec
01:08:36.532 [main] INFO  HeadREST - Starting validation of specification
01:08:39.166 [main] DEBUG Specification Helper - Use cache in semantic subtyping checking: true
01:08:39.167 [main] DEBUG Specification Helper - Simplify environment in semantic subtyping checking: true
01:08:39.167 [main] DEBUG Specification Helper - Preparing to validate specification with 1 resource types and 1 assertions
S:(declare-datatypes ((Value 0)) ((Value (G (out_G General)) (O (out_O SVMap)) (A (out_A IVMap)) (R (id Int) (type String)))))
(declare-datatypes ((General 0)) ((General (G_Boolean (of_G_Boolean Bool)) (G_Integer (of_G_Integer Int)) (G_String (of_G_String String)) (G_Null))))
(declare-datatypes ((ValueOption 0)) ((ValueOption (NoValue) (SomeValue (of_SomeValue Value)))))
(declare-sort IVMap)
(declare-sort SVMap)
(declare-fun v_has_field (Value String) Bool)
(declare-fun __dummy_v__ () Value)
(declare-fun v_integer (Int) Value)
(declare-fun v_nth (Value Value) Value)
(declare-fun v_dot (Value String) Value)
(declare-fun v_length (Value) Value)
(declare-fun ut_expand_simple_string_expansion (Value String) String)
(declare-fun Good_O (Value) Bool)
(declare-fun v_null () Value)
(declare-fun In_String (Value) Bool)
(declare-fun In_Boolean (Value) Bool)
(declare-fun r_resourceidof (Value Value) Value)
(declare-fun v_ff () Value)
(declare-fun Good_R (Value) Bool)
(declare-fun r_representationof (Value Value) Value)
(declare-fun v_contains (Value Value) Value)
(declare-fun Good_A (Value) Bool)
(declare-fun v_tt () Value)
(declare-fun alphai (IVMap) (Array Int ValueOption))
(declare-fun In_Integer (Value) Bool)
(declare-fun betai ((Array Int ValueOption)) IVMap)
(declare-fun alphas (SVMap) (Array String ValueOption))
(declare-fun betas ((Array String ValueOption)) SVMap)
(declare-fun v_matches ((RegEx String) Value) Value)
(declare-fun v_boolean (Bool) Value)
(declare-fun O_++ (Value Value) Value)
(declare-fun v_string (String) Value)
(declare-fun O_LE (Value Value) Value)
(declare-fun O_LT (Value Value) Value)
(declare-fun O_GT (Value Value) Value)
(declare-fun O_GE (Value Value) Value)
(declare-fun O_Or (Value Value) Value)
(declare-fun O_And (Value Value) Value)
(declare-fun O_Minus (Value) Value)
(declare-fun O_Not (Value) Value)
(declare-fun O_NE (Value Value) Value)
(declare-fun O_EQ (Value Value) Value)
(declare-fun O_Mult (Value Value) Value)
(declare-fun O_Sub (Value Value) Value)
(declare-fun O_Sum (Value Value) Value)
(declare-fun O_Implies (Value Value) Value)
(declare-fun O_Equiv (Value Value) Value)
(declare-fun ___1 () Value)
(assert (let ((a!1 (forall ((b Bool))
             (! (= (v_boolean b) (G (G_Boolean b))) :pattern ((v_boolean b)))))
      (a!2 (forall ((i Int))
             (! (= (v_integer i) (G (G_Integer i))) :pattern ((v_integer i)))))
      (a!3 (forall ((s String))
             (! (= (v_string s) (G (G_String s))) :pattern ((v_string s)))))
      (a!4 (forall ((v Value))
             (! (= (In_Boolean v) (and (is-G v) (is-G_Boolean (out_G v))))
                :pattern ((In_Boolean v)))))
      (a!5 (forall ((v Value))
             (! (= (In_Integer v) (and (is-G v) (is-G_Integer (out_G v))))
                :pattern ((In_Integer v)))))
      (a!6 (forall ((v Value))
             (! (= (In_String v) (and (is-G v) (is-G_String (out_G v))))
                :pattern ((In_String v)))))
      (a!7 (forall ((v1 Value) (v2 Value))
             (! (= (O_Equiv v1 v2) (ite (= v1 v2) v_tt v_ff))
                :pattern ((O_Equiv v1 v2)))))
      (a!8 (forall ((v1 Value) (v2 Value))
             (! (= (O_Implies v1 v2) (O_Or (O_Not v1) v2))
                :pattern ((O_Implies v1 v2)))))
      (a!9 (forall ((v1 Value) (v2 Value))
             (! (= (O_EQ v1 v2) (ite (= v1 v2) v_tt v_ff))
                :pattern ((O_EQ v1 v2)))))
      (a!10 (forall ((v1 Value) (v2 Value))
              (! (= (O_NE v1 v2) (ite (= v1 v2) v_ff v_tt))
                 :pattern ((O_NE v1 v2)))))
      (a!11 (forall ((v Value))
              (! (= (O_Not v) (ite (not (= v v_tt)) v_tt v_ff))
                 :pattern ((O_Not v)))))
      (a!12 (forall ((v1 Value) (v2 Value))
              (! (= (O_And v1 v2) (ite (and (= v1 v_tt) (= v2 v_tt)) v_tt v_ff))
                 :pattern ((O_And v1 v2)))))
      (a!13 (forall ((v1 Value) (v2 Value))
              (! (= (O_Or v1 v2) (ite (or (= v1 v_tt) (= v2 v_tt)) v_tt v_ff))
                 :pattern ((O_Or v1 v2)))))
      (a!14 (forall ((v Value))
              (! (let ((a!1 (= (str.len (of_G_String (out_G v)))
                               (of_G_Integer (out_G (v_length v))))))
                   (=> (and (is-G v) (is-G_String (out_G v))) a!1))
                 :pattern ((v_length v)))))
      (a!15 (forall ((am (Array String ValueOption)))
              (= (alphas (betas am)) am)))
      (a!16 (forall ((svm SVMap)) (= (betas (alphas svm)) svm)))
      (a!17 (forall ((l String) (svm SVMap))
              (! (let ((a!1 (not (= (select (alphas svm) l) NoValue))))
                   (= (v_has_field (O svm) l) a!1))
                 :pattern ((v_has_field (O svm) l)))))
      (a!18 (forall ((l String) (svm SVMap))
              (! (= (v_dot (O svm) l) (of_SomeValue (select (alphas svm) l)))
                 :pattern ((v_dot (O svm) l)))))
      (a!19 (forall ((l String) (svm SVMap))
              (! (not (is-R (v_dot (O svm) l))) :pattern ((v_dot (O svm) l)))))
      (a!20 (forall ((v Value) (l String))
              (! (not (= (v_dot v l) v)) :pattern ((v_dot v l)))))
      (a!21 (forall ((am (Array Int ValueOption))) (= (alphai (betai am)) am)))
      (a!22 (forall ((ivm IVMap)) (= (betai (alphai ivm)) ivm)))
      (a!23 (forall ((v Value))
              (let ((a!1 (>= (of_G_Integer (out_G (v_length v))) 0)))
                (and (In_Integer (v_length v)) a!1))))
      (a!24 (forall ((v Value))
              (! (forall ((i Int))
                   (let ((a!1 (< i (of_G_Integer (out_G (v_length v)))))
                         (a!2 (is-SomeValue (select (alphai (out_A v)) i))))
                     (=> (and (<= 0 i) a!1) a!2)))
                 :pattern ((Good_A v)))))
      (a!25 (forall ((v Value) (i Int))
              (! (let ((a!1 (of_SomeValue (select (alphai (out_A v)) i))))
                   (= (v_nth v (v_integer i)) a!1))
                 :pattern ((Good_A v) (v_nth v (v_integer i))))))
      (a!26 (forall ((v1 Value) (v2 Value))
              (! (not (= (v_nth v1 v2) v1)) :pattern ((v_nth v1 v2)))))
      (a!27 (forall ((r1 Value) (r2 Value))
              (! (= (= r1 r2) (= (id r1) (id r2)))
                 :pattern ((Good_R r1) (Good_R r2)))))
      (a!28 (forall ((v Value) (r Value))
              (! (=> (Good_R r) (=> (is-R v) (= (r_representationof v r) v_ff)))
                 :pattern ((r_representationof v r)))))
      (a!29 (forall ((v Value) (r Value))
              (! (=> (Good_R r)
                     (=> (not (In_String v)) (= (r_resourceidof v r) v_ff)))
                 :pattern ((r_resourceidof v r)))))
      (a!30 (forall ((v Value) (k String))
              (! (let ((a!1 (ite (of_G_Boolean (out_G (v_dot v k)))
                                 "true"
                                 "false")))
                   (=> (In_Boolean (v_dot v k))
                       (= (ut_expand_simple_string_expansion v k) a!1)))
                 :pattern ((Good_O v)
                           (v_has_field v k)
                           (ut_expand_simple_string_expansion v k)))))
      (a!31 (forall ((v Value) (k String))
              (! (let ((a!1 (= (ut_expand_simple_string_expansion v k)
                               (of_G_String (out_G (v_dot v k))))))
                   (=> (In_String (v_dot v k)) a!1))
                 :pattern ((Good_O v)
                           (v_has_field v k)
                           (ut_expand_simple_string_expansion v k)))))
      (a!32 (forall ((v Value) (k String))
              (! (=> (= (v_dot v k) v_null)
                     (= (ut_expand_simple_string_expansion v k) ""))
                 :pattern ((Good_O v)
                           (v_has_field v k)
                           (ut_expand_simple_string_expansion v k)))))
      (a!33 (forall ((v Value) (k String))
              (! (=> (not (v_has_field v k))
                     (= (ut_expand_simple_string_expansion v k) ""))
                 :pattern ((Good_O v) (ut_expand_simple_string_expansion v k))))))
  (and (forall ((v Value)) (! (= (Good_A v) (is-A v)) :pattern ((Good_A v))))
       (forall ((v Value)) (! (= (Good_O v) (is-O v)) :pattern ((Good_O v))))
       (forall ((v Value)) (! (= (Good_R v) (is-R v)) :pattern ((Good_R v))))
       (= v_tt (G (G_Boolean true)))
       (= v_ff (G (G_Boolean false)))
       (= v_null (G G_Null))
       a!1
       a!2
       a!3
       a!4
       a!5
       a!6
       a!7
       a!8
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_integer (+ (of_G_Integer (out_G v1))
                                     (of_G_Integer (out_G v2))))))
              (= (O_Sum v1 v2) a!1))
            :pattern ((O_Sum v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_integer (- (of_G_Integer (out_G v1))
                                     (of_G_Integer (out_G v2))))))
              (= (O_Sub v1 v2) a!1))
            :pattern ((O_Sub v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_integer (* (of_G_Integer (out_G v1))
                                     (of_G_Integer (out_G v2))))))
              (= (O_Mult v1 v2) a!1))
            :pattern ((O_Mult v1 v2))))
       a!9
       a!10
       a!11
       (forall ((v Value))
         (! (let ((a!1 (v_integer (- (of_G_Integer (out_G v))))))
              (= (O_Minus v) a!1))
            :pattern ((O_Minus v))))
       a!12
       a!13
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (>= (of_G_Integer (out_G v1))
                                (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_GE v1 v2) a!1))
            :pattern ((O_GE v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (> (of_G_Integer (out_G v1))
                               (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_GT v1 v2) a!1))
            :pattern ((O_GT v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (< (of_G_Integer (out_G v1))
                               (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_LT v1 v2) a!1))
            :pattern ((O_LT v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (<= (of_G_Integer (out_G v1))
                                (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_LE v1 v2) a!1))
            :pattern ((O_LE v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_string (str.++ (of_G_String (out_G v1))
                                         (of_G_String (out_G v2))))))
              (= (O_++ v1 v2) a!1))
            :pattern ((O_++ v1 v2))))
       a!14
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (str.contains (of_G_String (out_G v1))
                                          (of_G_String (out_G v2)))
                            v_tt
                            v_ff)))
              (= (v_contains v1 v2) a!1))
            :pattern ((In_String v1) (In_String v2) (v_contains v1 v2))))
       (forall ((r (RegEx String)) (v Value))
         (! (let ((a!1 (v_boolean (str.in.re (of_G_String (out_G v)) r))))
              (= (v_matches r v) a!1))
            :pattern ((In_String v) (v_matches r v))))
       a!15
       a!16
       (forall ((svm (Array String ValueOption))) (= (default svm) NoValue))
       a!17
       a!18
       a!19
       a!20
       a!21
       a!22
       (forall ((ivm (Array Int ValueOption))) (= (default ivm) NoValue))
       a!23
       a!24
       a!25
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (exists ((i Int))
                         (let ((a!1 (< i (of_G_Integer (out_G (v_length v1))))))
                           (and (<= 0 i) a!1 (= (v_nth v1 (v_integer i)) v2))))))
              (= (v_contains v1 v2) (ite a!1 v_tt v_ff)))
            :pattern ((Good_A v1) (v_contains v1 v2))))
       a!26
       a!27
       a!28
       a!29
       a!30
       a!31
       a!32
       a!33
       (= (v_length __dummy_v__) (v_integer 0))
       (= (v_dot __dummy_v__ "test") (v_integer 0))
       (= (v_nth __dummy_v__ __dummy_v__) (v_integer 0))
       (v_has_field __dummy_v__ "test"))))
(assert (let ((a!1 (G_Boolean (= ___1 (G (G_Integer 201))))))
(let ((a!2 (=> (and true (In_Integer ___1) (= (G a!1) v_tt)) (In_Integer ___1))))
  (not (and a!2)))))

unsat
S:(declare-datatypes ((Value 0)) ((Value (G (out_G General)) (O (out_O SVMap)) (A (out_A IVMap)) (R (id Int) (type String)))))
(declare-datatypes ((General 0)) ((General (G_Boolean (of_G_Boolean Bool)) (G_Integer (of_G_Integer Int)) (G_String (of_G_String String)) (G_Null))))
(declare-datatypes ((ValueOption 0)) ((ValueOption (NoValue) (SomeValue (of_SomeValue Value)))))
(declare-sort IVMap)
(declare-sort SVMap)
(declare-fun v_has_field (Value String) Bool)
(declare-fun __dummy_v__ () Value)
(declare-fun v_integer (Int) Value)
(declare-fun v_nth (Value Value) Value)
(declare-fun v_dot (Value String) Value)
(declare-fun v_length (Value) Value)
(declare-fun ut_expand_simple_string_expansion (Value String) String)
(declare-fun Good_O (Value) Bool)
(declare-fun v_null () Value)
(declare-fun In_String (Value) Bool)
(declare-fun In_Boolean (Value) Bool)
(declare-fun r_resourceidof (Value Value) Value)
(declare-fun v_ff () Value)
(declare-fun Good_R (Value) Bool)
(declare-fun r_representationof (Value Value) Value)
(declare-fun v_contains (Value Value) Value)
(declare-fun Good_A (Value) Bool)
(declare-fun v_tt () Value)
(declare-fun alphai (IVMap) (Array Int ValueOption))
(declare-fun In_Integer (Value) Bool)
(declare-fun betai ((Array Int ValueOption)) IVMap)
(declare-fun alphas (SVMap) (Array String ValueOption))
(declare-fun betas ((Array String ValueOption)) SVMap)
(declare-fun v_matches ((RegEx String) Value) Value)
(declare-fun v_boolean (Bool) Value)
(declare-fun O_++ (Value Value) Value)
(declare-fun v_string (String) Value)
(declare-fun O_LE (Value Value) Value)
(declare-fun O_LT (Value Value) Value)
(declare-fun O_GT (Value Value) Value)
(declare-fun O_GE (Value Value) Value)
(declare-fun O_Or (Value Value) Value)
(declare-fun O_And (Value Value) Value)
(declare-fun O_Minus (Value) Value)
(declare-fun O_Not (Value) Value)
(declare-fun O_NE (Value Value) Value)
(declare-fun O_EQ (Value Value) Value)
(declare-fun O_Mult (Value Value) Value)
(declare-fun O_Sub (Value Value) Value)
(declare-fun O_Sum (Value Value) Value)
(declare-fun O_Implies (Value Value) Value)
(declare-fun O_Equiv (Value Value) Value)
(declare-fun ___4 () Value)
(declare-fun request () Value)
(assert (let ((a!1 (forall ((b Bool))
             (! (= (v_boolean b) (G (G_Boolean b))) :pattern ((v_boolean b)))))
      (a!2 (forall ((i Int))
             (! (= (v_integer i) (G (G_Integer i))) :pattern ((v_integer i)))))
      (a!3 (forall ((s String))
             (! (= (v_string s) (G (G_String s))) :pattern ((v_string s)))))
      (a!4 (forall ((v Value))
             (! (= (In_Boolean v) (and (is-G v) (is-G_Boolean (out_G v))))
                :pattern ((In_Boolean v)))))
      (a!5 (forall ((v Value))
             (! (= (In_Integer v) (and (is-G v) (is-G_Integer (out_G v))))
                :pattern ((In_Integer v)))))
      (a!6 (forall ((v Value))
             (! (= (In_String v) (and (is-G v) (is-G_String (out_G v))))
                :pattern ((In_String v)))))
      (a!7 (forall ((v1 Value) (v2 Value))
             (! (= (O_Equiv v1 v2) (ite (= v1 v2) v_tt v_ff))
                :pattern ((O_Equiv v1 v2)))))
      (a!8 (forall ((v1 Value) (v2 Value))
             (! (= (O_Implies v1 v2) (O_Or (O_Not v1) v2))
                :pattern ((O_Implies v1 v2)))))
      (a!9 (forall ((v1 Value) (v2 Value))
             (! (= (O_EQ v1 v2) (ite (= v1 v2) v_tt v_ff))
                :pattern ((O_EQ v1 v2)))))
      (a!10 (forall ((v1 Value) (v2 Value))
              (! (= (O_NE v1 v2) (ite (= v1 v2) v_ff v_tt))
                 :pattern ((O_NE v1 v2)))))
      (a!11 (forall ((v Value))
              (! (= (O_Not v) (ite (not (= v v_tt)) v_tt v_ff))
                 :pattern ((O_Not v)))))
      (a!12 (forall ((v1 Value) (v2 Value))
              (! (= (O_And v1 v2) (ite (and (= v1 v_tt) (= v2 v_tt)) v_tt v_ff))
                 :pattern ((O_And v1 v2)))))
      (a!13 (forall ((v1 Value) (v2 Value))
              (! (= (O_Or v1 v2) (ite (or (= v1 v_tt) (= v2 v_tt)) v_tt v_ff))
                 :pattern ((O_Or v1 v2)))))
      (a!14 (forall ((v Value))
              (! (let ((a!1 (= (str.len (of_G_String (out_G v)))
                               (of_G_Integer (out_G (v_length v))))))
                   (=> (and (is-G v) (is-G_String (out_G v))) a!1))
                 :pattern ((v_length v)))))
      (a!15 (forall ((am (Array String ValueOption)))
              (= (alphas (betas am)) am)))
      (a!16 (forall ((svm SVMap)) (= (betas (alphas svm)) svm)))
      (a!17 (forall ((l String) (svm SVMap))
              (! (let ((a!1 (not (= (select (alphas svm) l) NoValue))))
                   (= (v_has_field (O svm) l) a!1))
                 :pattern ((v_has_field (O svm) l)))))
      (a!18 (forall ((l String) (svm SVMap))
              (! (= (v_dot (O svm) l) (of_SomeValue (select (alphas svm) l)))
                 :pattern ((v_dot (O svm) l)))))
      (a!19 (forall ((l String) (svm SVMap))
              (! (not (is-R (v_dot (O svm) l))) :pattern ((v_dot (O svm) l)))))
      (a!20 (forall ((v Value) (l String))
              (! (not (= (v_dot v l) v)) :pattern ((v_dot v l)))))
      (a!21 (forall ((am (Array Int ValueOption))) (= (alphai (betai am)) am)))
      (a!22 (forall ((ivm IVMap)) (= (betai (alphai ivm)) ivm)))
      (a!23 (forall ((v Value))
              (let ((a!1 (>= (of_G_Integer (out_G (v_length v))) 0)))
                (and (In_Integer (v_length v)) a!1))))
      (a!24 (forall ((v Value))
              (! (forall ((i Int))
                   (let ((a!1 (< i (of_G_Integer (out_G (v_length v)))))
                         (a!2 (is-SomeValue (select (alphai (out_A v)) i))))
                     (=> (and (<= 0 i) a!1) a!2)))
                 :pattern ((Good_A v)))))
      (a!25 (forall ((v Value) (i Int))
              (! (let ((a!1 (of_SomeValue (select (alphai (out_A v)) i))))
                   (= (v_nth v (v_integer i)) a!1))
                 :pattern ((Good_A v) (v_nth v (v_integer i))))))
      (a!26 (forall ((v1 Value) (v2 Value))
              (! (not (= (v_nth v1 v2) v1)) :pattern ((v_nth v1 v2)))))
      (a!27 (forall ((r1 Value) (r2 Value))
              (! (= (= r1 r2) (= (id r1) (id r2)))
                 :pattern ((Good_R r1) (Good_R r2)))))
      (a!28 (forall ((v Value) (r Value))
              (! (=> (Good_R r) (=> (is-R v) (= (r_representationof v r) v_ff)))
                 :pattern ((r_representationof v r)))))
      (a!29 (forall ((v Value) (r Value))
              (! (=> (Good_R r)
                     (=> (not (In_String v)) (= (r_resourceidof v r) v_ff)))
                 :pattern ((r_resourceidof v r)))))
      (a!30 (forall ((v Value) (k String))
              (! (let ((a!1 (ite (of_G_Boolean (out_G (v_dot v k)))
                                 "true"
                                 "false")))
                   (=> (In_Boolean (v_dot v k))
                       (= (ut_expand_simple_string_expansion v k) a!1)))
                 :pattern ((Good_O v)
                           (v_has_field v k)
                           (ut_expand_simple_string_expansion v k)))))
      (a!31 (forall ((v Value) (k String))
              (! (let ((a!1 (= (ut_expand_simple_string_expansion v k)
                               (of_G_String (out_G (v_dot v k))))))
                   (=> (In_String (v_dot v k)) a!1))
                 :pattern ((Good_O v)
                           (v_has_field v k)
                           (ut_expand_simple_string_expansion v k)))))
      (a!32 (forall ((v Value) (k String))
              (! (=> (= (v_dot v k) v_null)
                     (= (ut_expand_simple_string_expansion v k) ""))
                 :pattern ((Good_O v)
                           (v_has_field v k)
                           (ut_expand_simple_string_expansion v k)))))
      (a!33 (forall ((v Value) (k String))
              (! (=> (not (v_has_field v k))
                     (= (ut_expand_simple_string_expansion v k) ""))
                 :pattern ((Good_O v) (ut_expand_simple_string_expansion v k))))))
  (and (forall ((v Value)) (! (= (Good_A v) (is-A v)) :pattern ((Good_A v))))
       (forall ((v Value)) (! (= (Good_O v) (is-O v)) :pattern ((Good_O v))))
       (forall ((v Value)) (! (= (Good_R v) (is-R v)) :pattern ((Good_R v))))
       (= v_tt (G (G_Boolean true)))
       (= v_ff (G (G_Boolean false)))
       (= v_null (G G_Null))
       a!1
       a!2
       a!3
       a!4
       a!5
       a!6
       a!7
       a!8
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_integer (+ (of_G_Integer (out_G v1))
                                     (of_G_Integer (out_G v2))))))
              (= (O_Sum v1 v2) a!1))
            :pattern ((O_Sum v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_integer (- (of_G_Integer (out_G v1))
                                     (of_G_Integer (out_G v2))))))
              (= (O_Sub v1 v2) a!1))
            :pattern ((O_Sub v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_integer (* (of_G_Integer (out_G v1))
                                     (of_G_Integer (out_G v2))))))
              (= (O_Mult v1 v2) a!1))
            :pattern ((O_Mult v1 v2))))
       a!9
       a!10
       a!11
       (forall ((v Value))
         (! (let ((a!1 (v_integer (- (of_G_Integer (out_G v))))))
              (= (O_Minus v) a!1))
            :pattern ((O_Minus v))))
       a!12
       a!13
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (>= (of_G_Integer (out_G v1))
                                (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_GE v1 v2) a!1))
            :pattern ((O_GE v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (> (of_G_Integer (out_G v1))
                               (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_GT v1 v2) a!1))
            :pattern ((O_GT v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (< (of_G_Integer (out_G v1))
                               (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_LT v1 v2) a!1))
            :pattern ((O_LT v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (<= (of_G_Integer (out_G v1))
                                (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_LE v1 v2) a!1))
            :pattern ((O_LE v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_string (str.++ (of_G_String (out_G v1))
                                         (of_G_String (out_G v2))))))
              (= (O_++ v1 v2) a!1))
            :pattern ((O_++ v1 v2))))
       a!14
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (str.contains (of_G_String (out_G v1))
                                          (of_G_String (out_G v2)))
                            v_tt
                            v_ff)))
              (= (v_contains v1 v2) a!1))
            :pattern ((In_String v1) (In_String v2) (v_contains v1 v2))))
       (forall ((r (RegEx String)) (v Value))
         (! (let ((a!1 (v_boolean (str.in.re (of_G_String (out_G v)) r))))
              (= (v_matches r v) a!1))
            :pattern ((In_String v) (v_matches r v))))
       a!15
       a!16
       (forall ((svm (Array String ValueOption))) (= (default svm) NoValue))
       a!17
       a!18
       a!19
       a!20
       a!21
       a!22
       (forall ((ivm (Array Int ValueOption))) (= (default ivm) NoValue))
       a!23
       a!24
       a!25
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (exists ((i Int))
                         (let ((a!1 (< i (of_G_Integer (out_G (v_length v1))))))
                           (and (<= 0 i) a!1 (= (v_nth v1 (v_integer i)) v2))))))
              (= (v_contains v1 v2) (ite a!1 v_tt v_ff)))
            :pattern ((Good_A v1) (v_contains v1 v2))))
       a!26
       a!27
       a!28
       a!29
       a!30
       a!31
       a!32
       a!33
       (= (v_length __dummy_v__) (v_integer 0))
       (= (v_dot __dummy_v__ "test") (v_integer 0))
       (= (v_nth __dummy_v__ __dummy_v__) (v_integer 0))
       (v_has_field __dummy_v__ "test"))))
(assert (let ((a!1 (G_Boolean (and (Good_O request)
                           (v_has_field request "location")
                           (In_String (v_dot request "location")))))
      (a!2 (G_Boolean (and (Good_O request)
                           (v_has_field request "template")
                           (Good_O (v_dot request "template")))))
      (a!3 (G_Boolean (and (Good_O request)
                           (v_has_field request "header")
                           (Good_O (v_dot request "header")))))
      (a!5 (G_Boolean (and (Good_O ___4)
                           (v_has_field ___4 "location")
                           (In_String (v_dot ___4 "location")))))
      (a!6 (G_Boolean (and (Good_O ___4)
                           (v_has_field ___4 "template")
                           (Good_O (v_dot ___4 "template")))))
      (a!7 (G_Boolean (and (Good_O ___4)
                           (v_has_field ___4 "header")
                           (Good_O (v_dot ___4 "header"))))))
(let ((a!4 (= (O_And (O_And (G a!1) (G a!2)) (G a!3)) v_tt))
      (a!8 (= (O_And (O_And (G a!5) (G a!6)) (G a!7)) v_tt)))
(let ((a!9 (=> (and (Good_O request)
                    a!4
                    (Good_O ___4)
                    a!8
                    (= (O_EQ ___4 request) v_tt))
               (not (Good_R ___4)))))
  (not (and a!9))))))

unsat
S:(declare-datatypes ((Value 0)) ((Value (G (out_G General)) (O (out_O SVMap)) (A (out_A IVMap)) (R (id Int) (type String)))))
(declare-datatypes ((General 0)) ((General (G_Boolean (of_G_Boolean Bool)) (G_Integer (of_G_Integer Int)) (G_String (of_G_String String)) (G_Null))))
(declare-datatypes ((ValueOption 0)) ((ValueOption (NoValue) (SomeValue (of_SomeValue Value)))))
(declare-sort IVMap)
(declare-sort SVMap)
(declare-fun v_has_field (Value String) Bool)
(declare-fun __dummy_v__ () Value)
(declare-fun v_integer (Int) Value)
(declare-fun v_nth (Value Value) Value)
(declare-fun v_dot (Value String) Value)
(declare-fun v_length (Value) Value)
(declare-fun ut_expand_simple_string_expansion (Value String) String)
(declare-fun Good_O (Value) Bool)
(declare-fun v_null () Value)
(declare-fun In_String (Value) Bool)
(declare-fun In_Boolean (Value) Bool)
(declare-fun r_resourceidof (Value Value) Value)
(declare-fun v_ff () Value)
(declare-fun Good_R (Value) Bool)
(declare-fun r_representationof (Value Value) Value)
(declare-fun v_contains (Value Value) Value)
(declare-fun Good_A (Value) Bool)
(declare-fun v_tt () Value)
(declare-fun alphai (IVMap) (Array Int ValueOption))
(declare-fun In_Integer (Value) Bool)
(declare-fun betai ((Array Int ValueOption)) IVMap)
(declare-fun alphas (SVMap) (Array String ValueOption))
(declare-fun betas ((Array String ValueOption)) SVMap)
(declare-fun v_matches ((RegEx String) Value) Value)
(declare-fun v_boolean (Bool) Value)
(declare-fun O_++ (Value Value) Value)
(declare-fun v_string (String) Value)
(declare-fun O_LE (Value Value) Value)
(declare-fun O_LT (Value Value) Value)
(declare-fun O_GT (Value Value) Value)
(declare-fun O_GE (Value Value) Value)
(declare-fun O_Or (Value Value) Value)
(declare-fun O_And (Value Value) Value)
(declare-fun O_Minus (Value) Value)
(declare-fun O_Not (Value) Value)
(declare-fun O_NE (Value Value) Value)
(declare-fun O_EQ (Value Value) Value)
(declare-fun O_Mult (Value Value) Value)
(declare-fun O_Sub (Value Value) Value)
(declare-fun O_Sum (Value Value) Value)
(declare-fun O_Implies (Value Value) Value)
(declare-fun O_Equiv (Value Value) Value)
(declare-fun ___6 () Value)
(declare-fun request () Value)
(assert (let ((a!1 (forall ((b Bool))
             (! (= (v_boolean b) (G (G_Boolean b))) :pattern ((v_boolean b)))))
      (a!2 (forall ((i Int))
             (! (= (v_integer i) (G (G_Integer i))) :pattern ((v_integer i)))))
      (a!3 (forall ((s String))
             (! (= (v_string s) (G (G_String s))) :pattern ((v_string s)))))
      (a!4 (forall ((v Value))
             (! (= (In_Boolean v) (and (is-G v) (is-G_Boolean (out_G v))))
                :pattern ((In_Boolean v)))))
      (a!5 (forall ((v Value))
             (! (= (In_Integer v) (and (is-G v) (is-G_Integer (out_G v))))
                :pattern ((In_Integer v)))))
      (a!6 (forall ((v Value))
             (! (= (In_String v) (and (is-G v) (is-G_String (out_G v))))
                :pattern ((In_String v)))))
      (a!7 (forall ((v1 Value) (v2 Value))
             (! (= (O_Equiv v1 v2) (ite (= v1 v2) v_tt v_ff))
                :pattern ((O_Equiv v1 v2)))))
      (a!8 (forall ((v1 Value) (v2 Value))
             (! (= (O_Implies v1 v2) (O_Or (O_Not v1) v2))
                :pattern ((O_Implies v1 v2)))))
      (a!9 (forall ((v1 Value) (v2 Value))
             (! (= (O_EQ v1 v2) (ite (= v1 v2) v_tt v_ff))
                :pattern ((O_EQ v1 v2)))))
      (a!10 (forall ((v1 Value) (v2 Value))
              (! (= (O_NE v1 v2) (ite (= v1 v2) v_ff v_tt))
                 :pattern ((O_NE v1 v2)))))
      (a!11 (forall ((v Value))
              (! (= (O_Not v) (ite (not (= v v_tt)) v_tt v_ff))
                 :pattern ((O_Not v)))))
      (a!12 (forall ((v1 Value) (v2 Value))
              (! (= (O_And v1 v2) (ite (and (= v1 v_tt) (= v2 v_tt)) v_tt v_ff))
                 :pattern ((O_And v1 v2)))))
      (a!13 (forall ((v1 Value) (v2 Value))
              (! (= (O_Or v1 v2) (ite (or (= v1 v_tt) (= v2 v_tt)) v_tt v_ff))
                 :pattern ((O_Or v1 v2)))))
      (a!14 (forall ((v Value))
              (! (let ((a!1 (= (str.len (of_G_String (out_G v)))
                               (of_G_Integer (out_G (v_length v))))))
                   (=> (and (is-G v) (is-G_String (out_G v))) a!1))
                 :pattern ((v_length v)))))
      (a!15 (forall ((am (Array String ValueOption)))
              (= (alphas (betas am)) am)))
      (a!16 (forall ((svm SVMap)) (= (betas (alphas svm)) svm)))
      (a!17 (forall ((l String) (svm SVMap))
              (! (let ((a!1 (not (= (select (alphas svm) l) NoValue))))
                   (= (v_has_field (O svm) l) a!1))
                 :pattern ((v_has_field (O svm) l)))))
      (a!18 (forall ((l String) (svm SVMap))
              (! (= (v_dot (O svm) l) (of_SomeValue (select (alphas svm) l)))
                 :pattern ((v_dot (O svm) l)))))
      (a!19 (forall ((l String) (svm SVMap))
              (! (not (is-R (v_dot (O svm) l))) :pattern ((v_dot (O svm) l)))))
      (a!20 (forall ((v Value) (l String))
              (! (not (= (v_dot v l) v)) :pattern ((v_dot v l)))))
      (a!21 (forall ((am (Array Int ValueOption))) (= (alphai (betai am)) am)))
      (a!22 (forall ((ivm IVMap)) (= (betai (alphai ivm)) ivm)))
      (a!23 (forall ((v Value))
              (let ((a!1 (>= (of_G_Integer (out_G (v_length v))) 0)))
                (and (In_Integer (v_length v)) a!1))))
      (a!24 (forall ((v Value))
              (! (forall ((i Int))
                   (let ((a!1 (< i (of_G_Integer (out_G (v_length v)))))
                         (a!2 (is-SomeValue (select (alphai (out_A v)) i))))
                     (=> (and (<= 0 i) a!1) a!2)))
                 :pattern ((Good_A v)))))
      (a!25 (forall ((v Value) (i Int))
              (! (let ((a!1 (of_SomeValue (select (alphai (out_A v)) i))))
                   (= (v_nth v (v_integer i)) a!1))
                 :pattern ((Good_A v) (v_nth v (v_integer i))))))
      (a!26 (forall ((v1 Value) (v2 Value))
              (! (not (= (v_nth v1 v2) v1)) :pattern ((v_nth v1 v2)))))
      (a!27 (forall ((r1 Value) (r2 Value))
              (! (= (= r1 r2) (= (id r1) (id r2)))
                 :pattern ((Good_R r1) (Good_R r2)))))
      (a!28 (forall ((v Value) (r Value))
              (! (=> (Good_R r) (=> (is-R v) (= (r_representationof v r) v_ff)))
                 :pattern ((r_representationof v r)))))
      (a!29 (forall ((v Value) (r Value))
              (! (=> (Good_R r)
                     (=> (not (In_String v)) (= (r_resourceidof v r) v_ff)))
                 :pattern ((r_resourceidof v r)))))
      (a!30 (forall ((v Value) (k String))
              (! (let ((a!1 (ite (of_G_Boolean (out_G (v_dot v k)))
                                 "true"
                                 "false")))
                   (=> (In_Boolean (v_dot v k))
                       (= (ut_expand_simple_string_expansion v k) a!1)))
                 :pattern ((Good_O v)
                           (v_has_field v k)
                           (ut_expand_simple_string_expansion v k)))))
      (a!31 (forall ((v Value) (k String))
              (! (let ((a!1 (= (ut_expand_simple_string_expansion v k)
                               (of_G_String (out_G (v_dot v k))))))
                   (=> (In_String (v_dot v k)) a!1))
                 :pattern ((Good_O v)
                           (v_has_field v k)
                           (ut_expand_simple_string_expansion v k)))))
      (a!32 (forall ((v Value) (k String))
              (! (=> (= (v_dot v k) v_null)
                     (= (ut_expand_simple_string_expansion v k) ""))
                 :pattern ((Good_O v)
                           (v_has_field v k)
                           (ut_expand_simple_string_expansion v k)))))
      (a!33 (forall ((v Value) (k String))
              (! (=> (not (v_has_field v k))
                     (= (ut_expand_simple_string_expansion v k) ""))
                 :pattern ((Good_O v) (ut_expand_simple_string_expansion v k))))))
  (and (forall ((v Value)) (! (= (Good_A v) (is-A v)) :pattern ((Good_A v))))
       (forall ((v Value)) (! (= (Good_O v) (is-O v)) :pattern ((Good_O v))))
       (forall ((v Value)) (! (= (Good_R v) (is-R v)) :pattern ((Good_R v))))
       (= v_tt (G (G_Boolean true)))
       (= v_ff (G (G_Boolean false)))
       (= v_null (G G_Null))
       a!1
       a!2
       a!3
       a!4
       a!5
       a!6
       a!7
       a!8
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_integer (+ (of_G_Integer (out_G v1))
                                     (of_G_Integer (out_G v2))))))
              (= (O_Sum v1 v2) a!1))
            :pattern ((O_Sum v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_integer (- (of_G_Integer (out_G v1))
                                     (of_G_Integer (out_G v2))))))
              (= (O_Sub v1 v2) a!1))
            :pattern ((O_Sub v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_integer (* (of_G_Integer (out_G v1))
                                     (of_G_Integer (out_G v2))))))
              (= (O_Mult v1 v2) a!1))
            :pattern ((O_Mult v1 v2))))
       a!9
       a!10
       a!11
       (forall ((v Value))
         (! (let ((a!1 (v_integer (- (of_G_Integer (out_G v))))))
              (= (O_Minus v) a!1))
            :pattern ((O_Minus v))))
       a!12
       a!13
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (>= (of_G_Integer (out_G v1))
                                (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_GE v1 v2) a!1))
            :pattern ((O_GE v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (> (of_G_Integer (out_G v1))
                               (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_GT v1 v2) a!1))
            :pattern ((O_GT v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (< (of_G_Integer (out_G v1))
                               (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_LT v1 v2) a!1))
            :pattern ((O_LT v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (<= (of_G_Integer (out_G v1))
                                (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_LE v1 v2) a!1))
            :pattern ((O_LE v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_string (str.++ (of_G_String (out_G v1))
                                         (of_G_String (out_G v2))))))
              (= (O_++ v1 v2) a!1))
            :pattern ((O_++ v1 v2))))
       a!14
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (str.contains (of_G_String (out_G v1))
                                          (of_G_String (out_G v2)))
                            v_tt
                            v_ff)))
              (= (v_contains v1 v2) a!1))
            :pattern ((In_String v1) (In_String v2) (v_contains v1 v2))))
       (forall ((r (RegEx String)) (v Value))
         (! (let ((a!1 (v_boolean (str.in.re (of_G_String (out_G v)) r))))
              (= (v_matches r v) a!1))
            :pattern ((In_String v) (v_matches r v))))
       a!15
       a!16
       (forall ((svm (Array String ValueOption))) (= (default svm) NoValue))
       a!17
       a!18
       a!19
       a!20
       a!21
       a!22
       (forall ((ivm (Array Int ValueOption))) (= (default ivm) NoValue))
       a!23
       a!24
       a!25
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (exists ((i Int))
                         (let ((a!1 (< i (of_G_Integer (out_G (v_length v1))))))
                           (and (<= 0 i) a!1 (= (v_nth v1 (v_integer i)) v2))))))
              (= (v_contains v1 v2) (ite a!1 v_tt v_ff)))
            :pattern ((Good_A v1) (v_contains v1 v2))))
       a!26
       a!27
       a!28
       a!29
       a!30
       a!31
       a!32
       a!33
       (= (v_length __dummy_v__) (v_integer 0))
       (= (v_dot __dummy_v__ "test") (v_integer 0))
       (= (v_nth __dummy_v__ __dummy_v__) (v_integer 0))
       (v_has_field __dummy_v__ "test"))))
(assert (let ((a!1 (G_Boolean (and (Good_O request)
                           (v_has_field request "location")
                           (In_String (v_dot request "location")))))
      (a!2 (G_Boolean (and (Good_O request)
                           (v_has_field request "template")
                           (Good_O (v_dot request "template")))))
      (a!3 (G_Boolean (and (Good_O request)
                           (v_has_field request "header")
                           (Good_O (v_dot request "header")))))
      (a!5 (G_Boolean (and (Good_O request)
                           (v_has_field request "body")
                           (In_Integer (v_dot request "body"))))))
(let ((a!4 (= (O_And (O_And (G a!1) (G a!2)) (G a!3)) v_tt)))
(let ((a!6 (and (Good_O request)
                a!4
                (In_Boolean ___6)
                (= (O_EQ ___6 (G a!5)) v_tt))))
  (not (and (=> a!6 (In_Boolean ___6))))))))

unsat
S:(declare-datatypes ((Value 0)) ((Value (G (out_G General)) (O (out_O SVMap)) (A (out_A IVMap)) (R (id Int) (type String)))))
(declare-datatypes ((General 0)) ((General (G_Boolean (of_G_Boolean Bool)) (G_Integer (of_G_Integer Int)) (G_String (of_G_String String)) (G_Null))))
(declare-datatypes ((ValueOption 0)) ((ValueOption (NoValue) (SomeValue (of_SomeValue Value)))))
(declare-sort IVMap)
(declare-sort SVMap)
(declare-fun v_has_field (Value String) Bool)
(declare-fun __dummy_v__ () Value)
(declare-fun v_integer (Int) Value)
(declare-fun v_nth (Value Value) Value)
(declare-fun v_dot (Value String) Value)
(declare-fun v_length (Value) Value)
(declare-fun ut_expand_simple_string_expansion (Value String) String)
(declare-fun Good_O (Value) Bool)
(declare-fun v_null () Value)
(declare-fun In_String (Value) Bool)
(declare-fun In_Boolean (Value) Bool)
(declare-fun r_resourceidof (Value Value) Value)
(declare-fun v_ff () Value)
(declare-fun Good_R (Value) Bool)
(declare-fun r_representationof (Value Value) Value)
(declare-fun v_contains (Value Value) Value)
(declare-fun Good_A (Value) Bool)
(declare-fun v_tt () Value)
(declare-fun alphai (IVMap) (Array Int ValueOption))
(declare-fun In_Integer (Value) Bool)
(declare-fun betai ((Array Int ValueOption)) IVMap)
(declare-fun alphas (SVMap) (Array String ValueOption))
(declare-fun betas ((Array String ValueOption)) SVMap)
(declare-fun v_matches ((RegEx String) Value) Value)
(declare-fun v_boolean (Bool) Value)
(declare-fun O_++ (Value Value) Value)
(declare-fun v_string (String) Value)
(declare-fun O_LE (Value Value) Value)
(declare-fun O_LT (Value Value) Value)
(declare-fun O_GT (Value Value) Value)
(declare-fun O_GE (Value Value) Value)
(declare-fun O_Or (Value Value) Value)
(declare-fun O_And (Value Value) Value)
(declare-fun O_Minus (Value) Value)
(declare-fun O_Not (Value) Value)
(declare-fun O_NE (Value Value) Value)
(declare-fun O_EQ (Value Value) Value)
(declare-fun O_Mult (Value Value) Value)
(declare-fun O_Sub (Value Value) Value)
(declare-fun O_Sum (Value Value) Value)
(declare-fun O_Implies (Value Value) Value)
(declare-fun O_Equiv (Value Value) Value)
(declare-fun ___15 () Value)
(declare-fun c () Value)
(assert (let ((a!1 (forall ((b Bool))
             (! (= (v_boolean b) (G (G_Boolean b))) :pattern ((v_boolean b)))))
      (a!2 (forall ((i Int))
             (! (= (v_integer i) (G (G_Integer i))) :pattern ((v_integer i)))))
      (a!3 (forall ((s String))
             (! (= (v_string s) (G (G_String s))) :pattern ((v_string s)))))
      (a!4 (forall ((v Value))
             (! (= (In_Boolean v) (and (is-G v) (is-G_Boolean (out_G v))))
                :pattern ((In_Boolean v)))))
      (a!5 (forall ((v Value))
             (! (= (In_Integer v) (and (is-G v) (is-G_Integer (out_G v))))
                :pattern ((In_Integer v)))))
      (a!6 (forall ((v Value))
             (! (= (In_String v) (and (is-G v) (is-G_String (out_G v))))
                :pattern ((In_String v)))))
      (a!7 (forall ((v1 Value) (v2 Value))
             (! (= (O_Equiv v1 v2) (ite (= v1 v2) v_tt v_ff))
                :pattern ((O_Equiv v1 v2)))))
      (a!8 (forall ((v1 Value) (v2 Value))
             (! (= (O_Implies v1 v2) (O_Or (O_Not v1) v2))
                :pattern ((O_Implies v1 v2)))))
      (a!9 (forall ((v1 Value) (v2 Value))
             (! (= (O_EQ v1 v2) (ite (= v1 v2) v_tt v_ff))
                :pattern ((O_EQ v1 v2)))))
      (a!10 (forall ((v1 Value) (v2 Value))
              (! (= (O_NE v1 v2) (ite (= v1 v2) v_ff v_tt))
                 :pattern ((O_NE v1 v2)))))
      (a!11 (forall ((v Value))
              (! (= (O_Not v) (ite (not (= v v_tt)) v_tt v_ff))
                 :pattern ((O_Not v)))))
      (a!12 (forall ((v1 Value) (v2 Value))
              (! (= (O_And v1 v2) (ite (and (= v1 v_tt) (= v2 v_tt)) v_tt v_ff))
                 :pattern ((O_And v1 v2)))))
      (a!13 (forall ((v1 Value) (v2 Value))
              (! (= (O_Or v1 v2) (ite (or (= v1 v_tt) (= v2 v_tt)) v_tt v_ff))
                 :pattern ((O_Or v1 v2)))))
      (a!14 (forall ((v Value))
              (! (let ((a!1 (= (str.len (of_G_String (out_G v)))
                               (of_G_Integer (out_G (v_length v))))))
                   (=> (and (is-G v) (is-G_String (out_G v))) a!1))
                 :pattern ((v_length v)))))
      (a!15 (forall ((am (Array String ValueOption)))
              (= (alphas (betas am)) am)))
      (a!16 (forall ((svm SVMap)) (= (betas (alphas svm)) svm)))
      (a!17 (forall ((l String) (svm SVMap))
              (! (let ((a!1 (not (= (select (alphas svm) l) NoValue))))
                   (= (v_has_field (O svm) l) a!1))
                 :pattern ((v_has_field (O svm) l)))))
      (a!18 (forall ((l String) (svm SVMap))
              (! (= (v_dot (O svm) l) (of_SomeValue (select (alphas svm) l)))
                 :pattern ((v_dot (O svm) l)))))
      (a!19 (forall ((l String) (svm SVMap))
              (! (not (is-R (v_dot (O svm) l))) :pattern ((v_dot (O svm) l)))))
      (a!20 (forall ((v Value) (l String))
              (! (not (= (v_dot v l) v)) :pattern ((v_dot v l)))))
      (a!21 (forall ((am (Array Int ValueOption))) (= (alphai (betai am)) am)))
      (a!22 (forall ((ivm IVMap)) (= (betai (alphai ivm)) ivm)))
      (a!23 (forall ((v Value))
              (let ((a!1 (>= (of_G_Integer (out_G (v_length v))) 0)))
                (and (In_Integer (v_length v)) a!1))))
      (a!24 (forall ((v Value))
              (! (forall ((i Int))
                   (let ((a!1 (< i (of_G_Integer (out_G (v_length v)))))
                         (a!2 (is-SomeValue (select (alphai (out_A v)) i))))
                     (=> (and (<= 0 i) a!1) a!2)))
                 :pattern ((Good_A v)))))
      (a!25 (forall ((v Value) (i Int))
              (! (let ((a!1 (of_SomeValue (select (alphai (out_A v)) i))))
                   (= (v_nth v (v_integer i)) a!1))
                 :pattern ((Good_A v) (v_nth v (v_integer i))))))
      (a!26 (forall ((v1 Value) (v2 Value))
              (! (not (= (v_nth v1 v2) v1)) :pattern ((v_nth v1 v2)))))
      (a!27 (forall ((r1 Value) (r2 Value))
              (! (= (= r1 r2) (= (id r1) (id r2)))
                 :pattern ((Good_R r1) (Good_R r2)))))
      (a!28 (forall ((v Value) (r Value))
              (! (=> (Good_R r) (=> (is-R v) (= (r_representationof v r) v_ff)))
                 :pattern ((r_representationof v r)))))
      (a!29 (forall ((v Value) (r Value))
              (! (=> (Good_R r)
                     (=> (not (In_String v)) (= (r_resourceidof v r) v_ff)))
                 :pattern ((r_resourceidof v r)))))
      (a!30 (forall ((v Value) (k String))
              (! (let ((a!1 (ite (of_G_Boolean (out_G (v_dot v k)))
                                 "true"
                                 "false")))
                   (=> (In_Boolean (v_dot v k))
                       (= (ut_expand_simple_string_expansion v k) a!1)))
                 :pattern ((Good_O v)
                           (v_has_field v k)
                           (ut_expand_simple_string_expansion v k)))))
      (a!31 (forall ((v Value) (k String))
              (! (let ((a!1 (= (ut_expand_simple_string_expansion v k)
                               (of_G_String (out_G (v_dot v k))))))
                   (=> (In_String (v_dot v k)) a!1))
                 :pattern ((Good_O v)
                           (v_has_field v k)
                           (ut_expand_simple_string_expansion v k)))))
      (a!32 (forall ((v Value) (k String))
              (! (=> (= (v_dot v k) v_null)
                     (= (ut_expand_simple_string_expansion v k) ""))
                 :pattern ((Good_O v)
                           (v_has_field v k)
                           (ut_expand_simple_string_expansion v k)))))
      (a!33 (forall ((v Value) (k String))
              (! (=> (not (v_has_field v k))
                     (= (ut_expand_simple_string_expansion v k) ""))
                 :pattern ((Good_O v) (ut_expand_simple_string_expansion v k))))))
  (and (forall ((v Value)) (! (= (Good_A v) (is-A v)) :pattern ((Good_A v))))
       (forall ((v Value)) (! (= (Good_O v) (is-O v)) :pattern ((Good_O v))))
       (forall ((v Value)) (! (= (Good_R v) (is-R v)) :pattern ((Good_R v))))
       (= v_tt (G (G_Boolean true)))
       (= v_ff (G (G_Boolean false)))
       (= v_null (G G_Null))
       a!1
       a!2
       a!3
       a!4
       a!5
       a!6
       a!7
       a!8
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_integer (+ (of_G_Integer (out_G v1))
                                     (of_G_Integer (out_G v2))))))
              (= (O_Sum v1 v2) a!1))
            :pattern ((O_Sum v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_integer (- (of_G_Integer (out_G v1))
                                     (of_G_Integer (out_G v2))))))
              (= (O_Sub v1 v2) a!1))
            :pattern ((O_Sub v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_integer (* (of_G_Integer (out_G v1))
                                     (of_G_Integer (out_G v2))))))
              (= (O_Mult v1 v2) a!1))
            :pattern ((O_Mult v1 v2))))
       a!9
       a!10
       a!11
       (forall ((v Value))
         (! (let ((a!1 (v_integer (- (of_G_Integer (out_G v))))))
              (= (O_Minus v) a!1))
            :pattern ((O_Minus v))))
       a!12
       a!13
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (>= (of_G_Integer (out_G v1))
                                (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_GE v1 v2) a!1))
            :pattern ((O_GE v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (> (of_G_Integer (out_G v1))
                               (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_GT v1 v2) a!1))
            :pattern ((O_GT v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (< (of_G_Integer (out_G v1))
                               (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_LT v1 v2) a!1))
            :pattern ((O_LT v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (<= (of_G_Integer (out_G v1))
                                (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_LE v1 v2) a!1))
            :pattern ((O_LE v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_string (str.++ (of_G_String (out_G v1))
                                         (of_G_String (out_G v2))))))
              (= (O_++ v1 v2) a!1))
            :pattern ((O_++ v1 v2))))
       a!14
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (str.contains (of_G_String (out_G v1))
                                          (of_G_String (out_G v2)))
                            v_tt
                            v_ff)))
              (= (v_contains v1 v2) a!1))
            :pattern ((In_String v1) (In_String v2) (v_contains v1 v2))))
       (forall ((r (RegEx String)) (v Value))
         (! (let ((a!1 (v_boolean (str.in.re (of_G_String (out_G v)) r))))
              (= (v_matches r v) a!1))
            :pattern ((In_String v) (v_matches r v))))
       a!15
       a!16
       (forall ((svm (Array String ValueOption))) (= (default svm) NoValue))
       a!17
       a!18
       a!19
       a!20
       a!21
       a!22
       (forall ((ivm (Array Int ValueOption))) (= (default ivm) NoValue))
       a!23
       a!24
       a!25
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (exists ((i Int))
                         (let ((a!1 (< i (of_G_Integer (out_G (v_length v1))))))
                           (and (<= 0 i) a!1 (= (v_nth v1 (v_integer i)) v2))))))
              (= (v_contains v1 v2) (ite a!1 v_tt v_ff)))
            :pattern ((Good_A v1) (v_contains v1 v2))))
       a!26
       a!27
       a!28
       a!29
       a!30
       a!31
       a!32
       a!33
       (= (v_length __dummy_v__) (v_integer 0))
       (= (v_dot __dummy_v__ "test") (v_integer 0))
       (= (v_nth __dummy_v__ __dummy_v__) (v_integer 0))
       (v_has_field __dummy_v__ "test"))))
(assert (let ((a!1 (and (Good_O ___15)
                (v_has_field ___15 "id")
                (not (Good_R (v_dot ___15 "id"))))))
(let ((a!2 (=> (and (Good_R c)
                    (= (type c) "Contact")
                    (Good_R ___15)
                    (= (type ___15) "Contact")
                    (= (O_EQ ___15 c) v_tt))
               a!1)))
  (not (and a!2)))))

unknown
unknown
S:(declare-datatypes ((Value 0)) ((Value (G (out_G General)) (O (out_O SVMap)) (A (out_A IVMap)) (R (id Int) (type String)))))
(declare-datatypes ((General 0)) ((General (G_Boolean (of_G_Boolean Bool)) (G_Integer (of_G_Integer Int)) (G_String (of_G_String String)) (G_Null))))
(declare-datatypes ((ValueOption 0)) ((ValueOption (NoValue) (SomeValue (of_SomeValue Value)))))
(declare-sort IVMap)
(declare-sort SVMap)
(declare-fun v_has_field (Value String) Bool)
(declare-fun __dummy_v__ () Value)
(declare-fun v_integer (Int) Value)
(declare-fun v_nth (Value Value) Value)
(declare-fun v_dot (Value String) Value)
(declare-fun v_length (Value) Value)
(declare-fun ut_expand_simple_string_expansion (Value String) String)
(declare-fun Good_O (Value) Bool)
(declare-fun v_null () Value)
(declare-fun In_String (Value) Bool)
(declare-fun In_Boolean (Value) Bool)
(declare-fun r_resourceidof (Value Value) Value)
(declare-fun v_ff () Value)
(declare-fun Good_R (Value) Bool)
(declare-fun r_representationof (Value Value) Value)
(declare-fun v_contains (Value Value) Value)
(declare-fun Good_A (Value) Bool)
(declare-fun v_tt () Value)
(declare-fun alphai (IVMap) (Array Int ValueOption))
(declare-fun In_Integer (Value) Bool)
(declare-fun betai ((Array Int ValueOption)) IVMap)
(declare-fun alphas (SVMap) (Array String ValueOption))
(declare-fun betas ((Array String ValueOption)) SVMap)
(declare-fun v_matches ((RegEx String) Value) Value)
(declare-fun v_boolean (Bool) Value)
(declare-fun O_++ (Value Value) Value)
(declare-fun v_string (String) Value)
(declare-fun O_LE (Value Value) Value)
(declare-fun O_LT (Value Value) Value)
(declare-fun O_GT (Value Value) Value)
(declare-fun O_GE (Value Value) Value)
(declare-fun O_Or (Value Value) Value)
(declare-fun O_And (Value Value) Value)
(declare-fun O_Minus (Value) Value)
(declare-fun O_Not (Value) Value)
(declare-fun O_NE (Value Value) Value)
(declare-fun O_EQ (Value Value) Value)
(declare-fun O_Mult (Value Value) Value)
(declare-fun O_Sub (Value Value) Value)
(declare-fun O_Sum (Value Value) Value)
(declare-fun O_Implies (Value Value) Value)
(declare-fun O_Equiv (Value Value) Value)
(declare-fun ___17 () Value)
(declare-fun c () Value)
(assert (let ((a!1 (forall ((b Bool))
             (! (= (v_boolean b) (G (G_Boolean b))) :pattern ((v_boolean b)))))
      (a!2 (forall ((i Int))
             (! (= (v_integer i) (G (G_Integer i))) :pattern ((v_integer i)))))
      (a!3 (forall ((s String))
             (! (= (v_string s) (G (G_String s))) :pattern ((v_string s)))))
      (a!4 (forall ((v Value))
             (! (= (In_Boolean v) (and (is-G v) (is-G_Boolean (out_G v))))
                :pattern ((In_Boolean v)))))
      (a!5 (forall ((v Value))
             (! (= (In_Integer v) (and (is-G v) (is-G_Integer (out_G v))))
                :pattern ((In_Integer v)))))
      (a!6 (forall ((v Value))
             (! (= (In_String v) (and (is-G v) (is-G_String (out_G v))))
                :pattern ((In_String v)))))
      (a!7 (forall ((v1 Value) (v2 Value))
             (! (= (O_Equiv v1 v2) (ite (= v1 v2) v_tt v_ff))
                :pattern ((O_Equiv v1 v2)))))
      (a!8 (forall ((v1 Value) (v2 Value))
             (! (= (O_Implies v1 v2) (O_Or (O_Not v1) v2))
                :pattern ((O_Implies v1 v2)))))
      (a!9 (forall ((v1 Value) (v2 Value))
             (! (= (O_EQ v1 v2) (ite (= v1 v2) v_tt v_ff))
                :pattern ((O_EQ v1 v2)))))
      (a!10 (forall ((v1 Value) (v2 Value))
              (! (= (O_NE v1 v2) (ite (= v1 v2) v_ff v_tt))
                 :pattern ((O_NE v1 v2)))))
      (a!11 (forall ((v Value))
              (! (= (O_Not v) (ite (not (= v v_tt)) v_tt v_ff))
                 :pattern ((O_Not v)))))
      (a!12 (forall ((v1 Value) (v2 Value))
              (! (= (O_And v1 v2) (ite (and (= v1 v_tt) (= v2 v_tt)) v_tt v_ff))
                 :pattern ((O_And v1 v2)))))
      (a!13 (forall ((v1 Value) (v2 Value))
              (! (= (O_Or v1 v2) (ite (or (= v1 v_tt) (= v2 v_tt)) v_tt v_ff))
                 :pattern ((O_Or v1 v2)))))
      (a!14 (forall ((v Value))
              (! (let ((a!1 (= (str.len (of_G_String (out_G v)))
                               (of_G_Integer (out_G (v_length v))))))
                   (=> (and (is-G v) (is-G_String (out_G v))) a!1))
                 :pattern ((v_length v)))))
      (a!15 (forall ((am (Array String ValueOption)))
              (= (alphas (betas am)) am)))
      (a!16 (forall ((svm SVMap)) (= (betas (alphas svm)) svm)))
      (a!17 (forall ((l String) (svm SVMap))
              (! (let ((a!1 (not (= (select (alphas svm) l) NoValue))))
                   (= (v_has_field (O svm) l) a!1))
                 :pattern ((v_has_field (O svm) l)))))
      (a!18 (forall ((l String) (svm SVMap))
              (! (= (v_dot (O svm) l) (of_SomeValue (select (alphas svm) l)))
                 :pattern ((v_dot (O svm) l)))))
      (a!19 (forall ((l String) (svm SVMap))
              (! (not (is-R (v_dot (O svm) l))) :pattern ((v_dot (O svm) l)))))
      (a!20 (forall ((v Value) (l String))
              (! (not (= (v_dot v l) v)) :pattern ((v_dot v l)))))
      (a!21 (forall ((am (Array Int ValueOption))) (= (alphai (betai am)) am)))
      (a!22 (forall ((ivm IVMap)) (= (betai (alphai ivm)) ivm)))
      (a!23 (forall ((v Value))
              (let ((a!1 (>= (of_G_Integer (out_G (v_length v))) 0)))
                (and (In_Integer (v_length v)) a!1))))
      (a!24 (forall ((v Value))
              (! (forall ((i Int))
                   (let ((a!1 (< i (of_G_Integer (out_G (v_length v)))))
                         (a!2 (is-SomeValue (select (alphai (out_A v)) i))))
                     (=> (and (<= 0 i) a!1) a!2)))
                 :pattern ((Good_A v)))))
      (a!25 (forall ((v Value) (i Int))
              (! (let ((a!1 (of_SomeValue (select (alphai (out_A v)) i))))
                   (= (v_nth v (v_integer i)) a!1))
                 :pattern ((Good_A v) (v_nth v (v_integer i))))))
      (a!26 (forall ((v1 Value) (v2 Value))
              (! (not (= (v_nth v1 v2) v1)) :pattern ((v_nth v1 v2)))))
      (a!27 (forall ((r1 Value) (r2 Value))
              (! (= (= r1 r2) (= (id r1) (id r2)))
                 :pattern ((Good_R r1) (Good_R r2)))))
      (a!28 (forall ((v Value) (r Value))
              (! (=> (Good_R r) (=> (is-R v) (= (r_representationof v r) v_ff)))
                 :pattern ((r_representationof v r)))))
      (a!29 (forall ((v Value) (r Value))
              (! (=> (Good_R r)
                     (=> (not (In_String v)) (= (r_resourceidof v r) v_ff)))
                 :pattern ((r_resourceidof v r)))))
      (a!30 (forall ((v Value) (k String))
              (! (let ((a!1 (ite (of_G_Boolean (out_G (v_dot v k)))
                                 "true"
                                 "false")))
                   (=> (In_Boolean (v_dot v k))
                       (= (ut_expand_simple_string_expansion v k) a!1)))
                 :pattern ((Good_O v)
                           (v_has_field v k)
                           (ut_expand_simple_string_expansion v k)))))
      (a!31 (forall ((v Value) (k String))
              (! (let ((a!1 (= (ut_expand_simple_string_expansion v k)
                               (of_G_String (out_G (v_dot v k))))))
                   (=> (In_String (v_dot v k)) a!1))
                 :pattern ((Good_O v)
                           (v_has_field v k)
                           (ut_expand_simple_string_expansion v k)))))
      (a!32 (forall ((v Value) (k String))
              (! (=> (= (v_dot v k) v_null)
                     (= (ut_expand_simple_string_expansion v k) ""))
                 :pattern ((Good_O v)
                           (v_has_field v k)
                           (ut_expand_simple_string_expansion v k)))))
      (a!33 (forall ((v Value) (k String))
              (! (=> (not (v_has_field v k))
                     (= (ut_expand_simple_string_expansion v k) ""))
                 :pattern ((Good_O v) (ut_expand_simple_string_expansion v k))))))
  (and (forall ((v Value)) (! (= (Good_A v) (is-A v)) :pattern ((Good_A v))))
       (forall ((v Value)) (! (= (Good_O v) (is-O v)) :pattern ((Good_O v))))
       (forall ((v Value)) (! (= (Good_R v) (is-R v)) :pattern ((Good_R v))))
       (= v_tt (G (G_Boolean true)))
       (= v_ff (G (G_Boolean false)))
       (= v_null (G G_Null))
       a!1
       a!2
       a!3
       a!4
       a!5
       a!6
       a!7
       a!8
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_integer (+ (of_G_Integer (out_G v1))
                                     (of_G_Integer (out_G v2))))))
              (= (O_Sum v1 v2) a!1))
            :pattern ((O_Sum v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_integer (- (of_G_Integer (out_G v1))
                                     (of_G_Integer (out_G v2))))))
              (= (O_Sub v1 v2) a!1))
            :pattern ((O_Sub v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_integer (* (of_G_Integer (out_G v1))
                                     (of_G_Integer (out_G v2))))))
              (= (O_Mult v1 v2) a!1))
            :pattern ((O_Mult v1 v2))))
       a!9
       a!10
       a!11
       (forall ((v Value))
         (! (let ((a!1 (v_integer (- (of_G_Integer (out_G v))))))
              (= (O_Minus v) a!1))
            :pattern ((O_Minus v))))
       a!12
       a!13
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (>= (of_G_Integer (out_G v1))
                                (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_GE v1 v2) a!1))
            :pattern ((O_GE v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (> (of_G_Integer (out_G v1))
                               (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_GT v1 v2) a!1))
            :pattern ((O_GT v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (< (of_G_Integer (out_G v1))
                               (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_LT v1 v2) a!1))
            :pattern ((O_LT v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (<= (of_G_Integer (out_G v1))
                                (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_LE v1 v2) a!1))
            :pattern ((O_LE v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_string (str.++ (of_G_String (out_G v1))
                                         (of_G_String (out_G v2))))))
              (= (O_++ v1 v2) a!1))
            :pattern ((O_++ v1 v2))))
       a!14
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (str.contains (of_G_String (out_G v1))
                                          (of_G_String (out_G v2)))
                            v_tt
                            v_ff)))
              (= (v_contains v1 v2) a!1))
            :pattern ((In_String v1) (In_String v2) (v_contains v1 v2))))
       (forall ((r (RegEx String)) (v Value))
         (! (let ((a!1 (v_boolean (str.in.re (of_G_String (out_G v)) r))))
              (= (v_matches r v) a!1))
            :pattern ((In_String v) (v_matches r v))))
       a!15
       a!16
       (forall ((svm (Array String ValueOption))) (= (default svm) NoValue))
       a!17
       a!18
       a!19
       a!20
       a!21
       a!22
       (forall ((ivm (Array Int ValueOption))) (= (default ivm) NoValue))
       a!23
       a!24
       a!25
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (exists ((i Int))
                         (let ((a!1 (< i (of_G_Integer (out_G (v_length v1))))))
                           (and (<= 0 i) a!1 (= (v_nth v1 (v_integer i)) v2))))))
              (= (v_contains v1 v2) (ite a!1 v_tt v_ff)))
            :pattern ((Good_A v1) (v_contains v1 v2))))
       a!26
       a!27
       a!28
       a!29
       a!30
       a!31
       a!32
       a!33
       (= (v_length __dummy_v__) (v_integer 0))
       (= (v_dot __dummy_v__ "test") (v_integer 0))
       (= (v_nth __dummy_v__ __dummy_v__) (v_integer 0))
       (v_has_field __dummy_v__ "test"))))
(assert (let ((a!1 (G_Boolean (= (v_dot c "id") (G (G_Integer 0))))))
(let ((a!2 (and (Good_R c)
                (= (type c) "Contact")
                (In_Boolean ___17)
                (= (O_EQ ___17 (G a!1)) v_tt))))
  (not (and (=> a!2 (In_Boolean ___17)))))))

unsat
S:(declare-datatypes ((Value 0)) ((Value (G (out_G General)) (O (out_O SVMap)) (A (out_A IVMap)) (R (id Int) (type String)))))
(declare-datatypes ((General 0)) ((General (G_Boolean (of_G_Boolean Bool)) (G_Integer (of_G_Integer Int)) (G_String (of_G_String String)) (G_Null))))
(declare-datatypes ((ValueOption 0)) ((ValueOption (NoValue) (SomeValue (of_SomeValue Value)))))
(declare-sort IVMap)
(declare-sort SVMap)
(declare-fun v_has_field (Value String) Bool)
(declare-fun __dummy_v__ () Value)
(declare-fun v_integer (Int) Value)
(declare-fun v_nth (Value Value) Value)
(declare-fun v_dot (Value String) Value)
(declare-fun v_length (Value) Value)
(declare-fun ut_expand_simple_string_expansion (Value String) String)
(declare-fun Good_O (Value) Bool)
(declare-fun v_null () Value)
(declare-fun In_String (Value) Bool)
(declare-fun In_Boolean (Value) Bool)
(declare-fun r_resourceidof (Value Value) Value)
(declare-fun v_ff () Value)
(declare-fun Good_R (Value) Bool)
(declare-fun r_representationof (Value Value) Value)
(declare-fun v_contains (Value Value) Value)
(declare-fun Good_A (Value) Bool)
(declare-fun v_tt () Value)
(declare-fun alphai (IVMap) (Array Int ValueOption))
(declare-fun In_Integer (Value) Bool)
(declare-fun betai ((Array Int ValueOption)) IVMap)
(declare-fun alphas (SVMap) (Array String ValueOption))
(declare-fun betas ((Array String ValueOption)) SVMap)
(declare-fun v_matches ((RegEx String) Value) Value)
(declare-fun v_boolean (Bool) Value)
(declare-fun O_++ (Value Value) Value)
(declare-fun v_string (String) Value)
(declare-fun O_LE (Value Value) Value)
(declare-fun O_LT (Value Value) Value)
(declare-fun O_GT (Value Value) Value)
(declare-fun O_GE (Value Value) Value)
(declare-fun O_Or (Value Value) Value)
(declare-fun O_And (Value Value) Value)
(declare-fun O_Minus (Value) Value)
(declare-fun O_Not (Value) Value)
(declare-fun O_NE (Value Value) Value)
(declare-fun O_EQ (Value Value) Value)
(declare-fun O_Mult (Value Value) Value)
(declare-fun O_Sub (Value Value) Value)
(declare-fun O_Sum (Value Value) Value)
(declare-fun O_Implies (Value Value) Value)
(declare-fun O_Equiv (Value Value) Value)
(declare-fun ___21 () Value)
(assert (let ((a!1 (forall ((b Bool))
             (! (= (v_boolean b) (G (G_Boolean b))) :pattern ((v_boolean b)))))
      (a!2 (forall ((i Int))
             (! (= (v_integer i) (G (G_Integer i))) :pattern ((v_integer i)))))
      (a!3 (forall ((s String))
             (! (= (v_string s) (G (G_String s))) :pattern ((v_string s)))))
      (a!4 (forall ((v Value))
             (! (= (In_Boolean v) (and (is-G v) (is-G_Boolean (out_G v))))
                :pattern ((In_Boolean v)))))
      (a!5 (forall ((v Value))
             (! (= (In_Integer v) (and (is-G v) (is-G_Integer (out_G v))))
                :pattern ((In_Integer v)))))
      (a!6 (forall ((v Value))
             (! (= (In_String v) (and (is-G v) (is-G_String (out_G v))))
                :pattern ((In_String v)))))
      (a!7 (forall ((v1 Value) (v2 Value))
             (! (= (O_Equiv v1 v2) (ite (= v1 v2) v_tt v_ff))
                :pattern ((O_Equiv v1 v2)))))
      (a!8 (forall ((v1 Value) (v2 Value))
             (! (= (O_Implies v1 v2) (O_Or (O_Not v1) v2))
                :pattern ((O_Implies v1 v2)))))
      (a!9 (forall ((v1 Value) (v2 Value))
             (! (= (O_EQ v1 v2) (ite (= v1 v2) v_tt v_ff))
                :pattern ((O_EQ v1 v2)))))
      (a!10 (forall ((v1 Value) (v2 Value))
              (! (= (O_NE v1 v2) (ite (= v1 v2) v_ff v_tt))
                 :pattern ((O_NE v1 v2)))))
      (a!11 (forall ((v Value))
              (! (= (O_Not v) (ite (not (= v v_tt)) v_tt v_ff))
                 :pattern ((O_Not v)))))
      (a!12 (forall ((v1 Value) (v2 Value))
              (! (= (O_And v1 v2) (ite (and (= v1 v_tt) (= v2 v_tt)) v_tt v_ff))
                 :pattern ((O_And v1 v2)))))
      (a!13 (forall ((v1 Value) (v2 Value))
              (! (= (O_Or v1 v2) (ite (or (= v1 v_tt) (= v2 v_tt)) v_tt v_ff))
                 :pattern ((O_Or v1 v2)))))
      (a!14 (forall ((v Value))
              (! (let ((a!1 (= (str.len (of_G_String (out_G v)))
                               (of_G_Integer (out_G (v_length v))))))
                   (=> (and (is-G v) (is-G_String (out_G v))) a!1))
                 :pattern ((v_length v)))))
      (a!15 (forall ((am (Array String ValueOption)))
              (= (alphas (betas am)) am)))
      (a!16 (forall ((svm SVMap)) (= (betas (alphas svm)) svm)))
      (a!17 (forall ((l String) (svm SVMap))
              (! (let ((a!1 (not (= (select (alphas svm) l) NoValue))))
                   (= (v_has_field (O svm) l) a!1))
                 :pattern ((v_has_field (O svm) l)))))
      (a!18 (forall ((l String) (svm SVMap))
              (! (= (v_dot (O svm) l) (of_SomeValue (select (alphas svm) l)))
                 :pattern ((v_dot (O svm) l)))))
      (a!19 (forall ((l String) (svm SVMap))
              (! (not (is-R (v_dot (O svm) l))) :pattern ((v_dot (O svm) l)))))
      (a!20 (forall ((v Value) (l String))
              (! (not (= (v_dot v l) v)) :pattern ((v_dot v l)))))
      (a!21 (forall ((am (Array Int ValueOption))) (= (alphai (betai am)) am)))
      (a!22 (forall ((ivm IVMap)) (= (betai (alphai ivm)) ivm)))
      (a!23 (forall ((v Value))
              (let ((a!1 (>= (of_G_Integer (out_G (v_length v))) 0)))
                (and (In_Integer (v_length v)) a!1))))
      (a!24 (forall ((v Value))
              (! (forall ((i Int))
                   (let ((a!1 (< i (of_G_Integer (out_G (v_length v)))))
                         (a!2 (is-SomeValue (select (alphai (out_A v)) i))))
                     (=> (and (<= 0 i) a!1) a!2)))
                 :pattern ((Good_A v)))))
      (a!25 (forall ((v Value) (i Int))
              (! (let ((a!1 (of_SomeValue (select (alphai (out_A v)) i))))
                   (= (v_nth v (v_integer i)) a!1))
                 :pattern ((Good_A v) (v_nth v (v_integer i))))))
      (a!26 (forall ((v1 Value) (v2 Value))
              (! (not (= (v_nth v1 v2) v1)) :pattern ((v_nth v1 v2)))))
      (a!27 (forall ((r1 Value) (r2 Value))
              (! (= (= r1 r2) (= (id r1) (id r2)))
                 :pattern ((Good_R r1) (Good_R r2)))))
      (a!28 (forall ((v Value) (r Value))
              (! (=> (Good_R r) (=> (is-R v) (= (r_representationof v r) v_ff)))
                 :pattern ((r_representationof v r)))))
      (a!29 (forall ((v Value) (r Value))
              (! (=> (Good_R r)
                     (=> (not (In_String v)) (= (r_resourceidof v r) v_ff)))
                 :pattern ((r_resourceidof v r)))))
      (a!30 (forall ((v Value) (k String))
              (! (let ((a!1 (ite (of_G_Boolean (out_G (v_dot v k)))
                                 "true"
                                 "false")))
                   (=> (In_Boolean (v_dot v k))
                       (= (ut_expand_simple_string_expansion v k) a!1)))
                 :pattern ((Good_O v)
                           (v_has_field v k)
                           (ut_expand_simple_string_expansion v k)))))
      (a!31 (forall ((v Value) (k String))
              (! (let ((a!1 (= (ut_expand_simple_string_expansion v k)
                               (of_G_String (out_G (v_dot v k))))))
                   (=> (In_String (v_dot v k)) a!1))
                 :pattern ((Good_O v)
                           (v_has_field v k)
                           (ut_expand_simple_string_expansion v k)))))
      (a!32 (forall ((v Value) (k String))
              (! (=> (= (v_dot v k) v_null)
                     (= (ut_expand_simple_string_expansion v k) ""))
                 :pattern ((Good_O v)
                           (v_has_field v k)
                           (ut_expand_simple_string_expansion v k)))))
      (a!33 (forall ((v Value) (k String))
              (! (=> (not (v_has_field v k))
                     (= (ut_expand_simple_string_expansion v k) ""))
                 :pattern ((Good_O v) (ut_expand_simple_string_expansion v k))))))
  (and (forall ((v Value)) (! (= (Good_A v) (is-A v)) :pattern ((Good_A v))))
       (forall ((v Value)) (! (= (Good_O v) (is-O v)) :pattern ((Good_O v))))
       (forall ((v Value)) (! (= (Good_R v) (is-R v)) :pattern ((Good_R v))))
       (= v_tt (G (G_Boolean true)))
       (= v_ff (G (G_Boolean false)))
       (= v_null (G G_Null))
       a!1
       a!2
       a!3
       a!4
       a!5
       a!6
       a!7
       a!8
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_integer (+ (of_G_Integer (out_G v1))
                                     (of_G_Integer (out_G v2))))))
              (= (O_Sum v1 v2) a!1))
            :pattern ((O_Sum v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_integer (- (of_G_Integer (out_G v1))
                                     (of_G_Integer (out_G v2))))))
              (= (O_Sub v1 v2) a!1))
            :pattern ((O_Sub v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_integer (* (of_G_Integer (out_G v1))
                                     (of_G_Integer (out_G v2))))))
              (= (O_Mult v1 v2) a!1))
            :pattern ((O_Mult v1 v2))))
       a!9
       a!10
       a!11
       (forall ((v Value))
         (! (let ((a!1 (v_integer (- (of_G_Integer (out_G v))))))
              (= (O_Minus v) a!1))
            :pattern ((O_Minus v))))
       a!12
       a!13
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (>= (of_G_Integer (out_G v1))
                                (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_GE v1 v2) a!1))
            :pattern ((O_GE v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (> (of_G_Integer (out_G v1))
                               (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_GT v1 v2) a!1))
            :pattern ((O_GT v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (< (of_G_Integer (out_G v1))
                               (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_LT v1 v2) a!1))
            :pattern ((O_LT v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (<= (of_G_Integer (out_G v1))
                                (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_LE v1 v2) a!1))
            :pattern ((O_LE v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_string (str.++ (of_G_String (out_G v1))
                                         (of_G_String (out_G v2))))))
              (= (O_++ v1 v2) a!1))
            :pattern ((O_++ v1 v2))))
       a!14
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (str.contains (of_G_String (out_G v1))
                                          (of_G_String (out_G v2)))
                            v_tt
                            v_ff)))
              (= (v_contains v1 v2) a!1))
            :pattern ((In_String v1) (In_String v2) (v_contains v1 v2))))
       (forall ((r (RegEx String)) (v Value))
         (! (let ((a!1 (v_boolean (str.in.re (of_G_String (out_G v)) r))))
              (= (v_matches r v) a!1))
            :pattern ((In_String v) (v_matches r v))))
       a!15
       a!16
       (forall ((svm (Array String ValueOption))) (= (default svm) NoValue))
       a!17
       a!18
       a!19
       a!20
       a!21
       a!22
       (forall ((ivm (Array Int ValueOption))) (= (default ivm) NoValue))
       a!23
       a!24
       a!25
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (exists ((i Int))
                         (let ((a!1 (< i (of_G_Integer (out_G (v_length v1))))))
                           (and (<= 0 i) a!1 (= (v_nth v1 (v_integer i)) v2))))))
              (= (v_contains v1 v2) (ite a!1 v_tt v_ff)))
            :pattern ((Good_A v1) (v_contains v1 v2))))
       a!26
       a!27
       a!28
       a!29
       a!30
       a!31
       a!32
       a!33
       (= (v_length __dummy_v__) (v_integer 0))
       (= (v_dot __dummy_v__ "test") (v_integer 0))
       (= (v_nth __dummy_v__ __dummy_v__) (v_integer 0))
       (v_has_field __dummy_v__ "test"))))
(assert (let ((a!1 (G_Boolean (= ___21 (G (G_Boolean false))))))
(let ((a!2 (=> (and true (In_Boolean ___21) (= (G a!1) v_tt))
               (In_Boolean ___21))))
  (not (and a!2)))))

unsat
S:(declare-datatypes ((Value 0)) ((Value (G (out_G General)) (O (out_O SVMap)) (A (out_A IVMap)) (R (id Int) (type String)))))
(declare-datatypes ((General 0)) ((General (G_Boolean (of_G_Boolean Bool)) (G_Integer (of_G_Integer Int)) (G_String (of_G_String String)) (G_Null))))
(declare-datatypes ((ValueOption 0)) ((ValueOption (NoValue) (SomeValue (of_SomeValue Value)))))
(declare-sort IVMap)
(declare-sort SVMap)
(declare-fun v_has_field (Value String) Bool)
(declare-fun __dummy_v__ () Value)
(declare-fun v_integer (Int) Value)
(declare-fun v_nth (Value Value) Value)
(declare-fun v_dot (Value String) Value)
(declare-fun v_length (Value) Value)
(declare-fun ut_expand_simple_string_expansion (Value String) String)
(declare-fun Good_O (Value) Bool)
(declare-fun v_null () Value)
(declare-fun In_String (Value) Bool)
(declare-fun In_Boolean (Value) Bool)
(declare-fun r_resourceidof (Value Value) Value)
(declare-fun v_ff () Value)
(declare-fun Good_R (Value) Bool)
(declare-fun r_representationof (Value Value) Value)
(declare-fun v_contains (Value Value) Value)
(declare-fun Good_A (Value) Bool)
(declare-fun v_tt () Value)
(declare-fun alphai (IVMap) (Array Int ValueOption))
(declare-fun In_Integer (Value) Bool)
(declare-fun betai ((Array Int ValueOption)) IVMap)
(declare-fun alphas (SVMap) (Array String ValueOption))
(declare-fun betas ((Array String ValueOption)) SVMap)
(declare-fun v_matches ((RegEx String) Value) Value)
(declare-fun v_boolean (Bool) Value)
(declare-fun O_++ (Value Value) Value)
(declare-fun v_string (String) Value)
(declare-fun O_LE (Value Value) Value)
(declare-fun O_LT (Value Value) Value)
(declare-fun O_GT (Value Value) Value)
(declare-fun O_GE (Value Value) Value)
(declare-fun O_Or (Value Value) Value)
(declare-fun O_And (Value Value) Value)
(declare-fun O_Minus (Value) Value)
(declare-fun O_Not (Value) Value)
(declare-fun O_NE (Value Value) Value)
(declare-fun O_EQ (Value Value) Value)
(declare-fun O_Mult (Value Value) Value)
(declare-fun O_Sub (Value Value) Value)
(declare-fun O_Sum (Value Value) Value)
(declare-fun O_Implies (Value Value) Value)
(declare-fun O_Equiv (Value Value) Value)
(declare-fun ___36 () Value)
(declare-fun response () Value)
(assert (let ((a!1 (forall ((b Bool))
             (! (= (v_boolean b) (G (G_Boolean b))) :pattern ((v_boolean b)))))
      (a!2 (forall ((i Int))
             (! (= (v_integer i) (G (G_Integer i))) :pattern ((v_integer i)))))
      (a!3 (forall ((s String))
             (! (= (v_string s) (G (G_String s))) :pattern ((v_string s)))))
      (a!4 (forall ((v Value))
             (! (= (In_Boolean v) (and (is-G v) (is-G_Boolean (out_G v))))
                :pattern ((In_Boolean v)))))
      (a!5 (forall ((v Value))
             (! (= (In_Integer v) (and (is-G v) (is-G_Integer (out_G v))))
                :pattern ((In_Integer v)))))
      (a!6 (forall ((v Value))
             (! (= (In_String v) (and (is-G v) (is-G_String (out_G v))))
                :pattern ((In_String v)))))
      (a!7 (forall ((v1 Value) (v2 Value))
             (! (= (O_Equiv v1 v2) (ite (= v1 v2) v_tt v_ff))
                :pattern ((O_Equiv v1 v2)))))
      (a!8 (forall ((v1 Value) (v2 Value))
             (! (= (O_Implies v1 v2) (O_Or (O_Not v1) v2))
                :pattern ((O_Implies v1 v2)))))
      (a!9 (forall ((v1 Value) (v2 Value))
             (! (= (O_EQ v1 v2) (ite (= v1 v2) v_tt v_ff))
                :pattern ((O_EQ v1 v2)))))
      (a!10 (forall ((v1 Value) (v2 Value))
              (! (= (O_NE v1 v2) (ite (= v1 v2) v_ff v_tt))
                 :pattern ((O_NE v1 v2)))))
      (a!11 (forall ((v Value))
              (! (= (O_Not v) (ite (not (= v v_tt)) v_tt v_ff))
                 :pattern ((O_Not v)))))
      (a!12 (forall ((v1 Value) (v2 Value))
              (! (= (O_And v1 v2) (ite (and (= v1 v_tt) (= v2 v_tt)) v_tt v_ff))
                 :pattern ((O_And v1 v2)))))
      (a!13 (forall ((v1 Value) (v2 Value))
              (! (= (O_Or v1 v2) (ite (or (= v1 v_tt) (= v2 v_tt)) v_tt v_ff))
                 :pattern ((O_Or v1 v2)))))
      (a!14 (forall ((v Value))
              (! (let ((a!1 (= (str.len (of_G_String (out_G v)))
                               (of_G_Integer (out_G (v_length v))))))
                   (=> (and (is-G v) (is-G_String (out_G v))) a!1))
                 :pattern ((v_length v)))))
      (a!15 (forall ((am (Array String ValueOption)))
              (= (alphas (betas am)) am)))
      (a!16 (forall ((svm SVMap)) (= (betas (alphas svm)) svm)))
      (a!17 (forall ((l String) (svm SVMap))
              (! (let ((a!1 (not (= (select (alphas svm) l) NoValue))))
                   (= (v_has_field (O svm) l) a!1))
                 :pattern ((v_has_field (O svm) l)))))
      (a!18 (forall ((l String) (svm SVMap))
              (! (= (v_dot (O svm) l) (of_SomeValue (select (alphas svm) l)))
                 :pattern ((v_dot (O svm) l)))))
      (a!19 (forall ((l String) (svm SVMap))
              (! (not (is-R (v_dot (O svm) l))) :pattern ((v_dot (O svm) l)))))
      (a!20 (forall ((v Value) (l String))
              (! (not (= (v_dot v l) v)) :pattern ((v_dot v l)))))
      (a!21 (forall ((am (Array Int ValueOption))) (= (alphai (betai am)) am)))
      (a!22 (forall ((ivm IVMap)) (= (betai (alphai ivm)) ivm)))
      (a!23 (forall ((v Value))
              (let ((a!1 (>= (of_G_Integer (out_G (v_length v))) 0)))
                (and (In_Integer (v_length v)) a!1))))
      (a!24 (forall ((v Value))
              (! (forall ((i Int))
                   (let ((a!1 (< i (of_G_Integer (out_G (v_length v)))))
                         (a!2 (is-SomeValue (select (alphai (out_A v)) i))))
                     (=> (and (<= 0 i) a!1) a!2)))
                 :pattern ((Good_A v)))))
      (a!25 (forall ((v Value) (i Int))
              (! (let ((a!1 (of_SomeValue (select (alphai (out_A v)) i))))
                   (= (v_nth v (v_integer i)) a!1))
                 :pattern ((Good_A v) (v_nth v (v_integer i))))))
      (a!26 (forall ((v1 Value) (v2 Value))
              (! (not (= (v_nth v1 v2) v1)) :pattern ((v_nth v1 v2)))))
      (a!27 (forall ((r1 Value) (r2 Value))
              (! (= (= r1 r2) (= (id r1) (id r2)))
                 :pattern ((Good_R r1) (Good_R r2)))))
      (a!28 (forall ((v Value) (r Value))
              (! (=> (Good_R r) (=> (is-R v) (= (r_representationof v r) v_ff)))
                 :pattern ((r_representationof v r)))))
      (a!29 (forall ((v Value) (r Value))
              (! (=> (Good_R r)
                     (=> (not (In_String v)) (= (r_resourceidof v r) v_ff)))
                 :pattern ((r_resourceidof v r)))))
      (a!30 (forall ((v Value) (k String))
              (! (let ((a!1 (ite (of_G_Boolean (out_G (v_dot v k)))
                                 "true"
                                 "false")))
                   (=> (In_Boolean (v_dot v k))
                       (= (ut_expand_simple_string_expansion v k) a!1)))
                 :pattern ((Good_O v)
                           (v_has_field v k)
                           (ut_expand_simple_string_expansion v k)))))
      (a!31 (forall ((v Value) (k String))
              (! (let ((a!1 (= (ut_expand_simple_string_expansion v k)
                               (of_G_String (out_G (v_dot v k))))))
                   (=> (In_String (v_dot v k)) a!1))
                 :pattern ((Good_O v)
                           (v_has_field v k)
                           (ut_expand_simple_string_expansion v k)))))
      (a!32 (forall ((v Value) (k String))
              (! (=> (= (v_dot v k) v_null)
                     (= (ut_expand_simple_string_expansion v k) ""))
                 :pattern ((Good_O v)
                           (v_has_field v k)
                           (ut_expand_simple_string_expansion v k)))))
      (a!33 (forall ((v Value) (k String))
              (! (=> (not (v_has_field v k))
                     (= (ut_expand_simple_string_expansion v k) ""))
                 :pattern ((Good_O v) (ut_expand_simple_string_expansion v k))))))
  (and (forall ((v Value)) (! (= (Good_A v) (is-A v)) :pattern ((Good_A v))))
       (forall ((v Value)) (! (= (Good_O v) (is-O v)) :pattern ((Good_O v))))
       (forall ((v Value)) (! (= (Good_R v) (is-R v)) :pattern ((Good_R v))))
       (= v_tt (G (G_Boolean true)))
       (= v_ff (G (G_Boolean false)))
       (= v_null (G G_Null))
       a!1
       a!2
       a!3
       a!4
       a!5
       a!6
       a!7
       a!8
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_integer (+ (of_G_Integer (out_G v1))
                                     (of_G_Integer (out_G v2))))))
              (= (O_Sum v1 v2) a!1))
            :pattern ((O_Sum v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_integer (- (of_G_Integer (out_G v1))
                                     (of_G_Integer (out_G v2))))))
              (= (O_Sub v1 v2) a!1))
            :pattern ((O_Sub v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_integer (* (of_G_Integer (out_G v1))
                                     (of_G_Integer (out_G v2))))))
              (= (O_Mult v1 v2) a!1))
            :pattern ((O_Mult v1 v2))))
       a!9
       a!10
       a!11
       (forall ((v Value))
         (! (let ((a!1 (v_integer (- (of_G_Integer (out_G v))))))
              (= (O_Minus v) a!1))
            :pattern ((O_Minus v))))
       a!12
       a!13
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (>= (of_G_Integer (out_G v1))
                                (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_GE v1 v2) a!1))
            :pattern ((O_GE v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (> (of_G_Integer (out_G v1))
                               (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_GT v1 v2) a!1))
            :pattern ((O_GT v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (< (of_G_Integer (out_G v1))
                               (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_LT v1 v2) a!1))
            :pattern ((O_LT v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (<= (of_G_Integer (out_G v1))
                                (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_LE v1 v2) a!1))
            :pattern ((O_LE v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_string (str.++ (of_G_String (out_G v1))
                                         (of_G_String (out_G v2))))))
              (= (O_++ v1 v2) a!1))
            :pattern ((O_++ v1 v2))))
       a!14
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (str.contains (of_G_String (out_G v1))
                                          (of_G_String (out_G v2)))
                            v_tt
                            v_ff)))
              (= (v_contains v1 v2) a!1))
            :pattern ((In_String v1) (In_String v2) (v_contains v1 v2))))
       (forall ((r (RegEx String)) (v Value))
         (! (let ((a!1 (v_boolean (str.in.re (of_G_String (out_G v)) r))))
              (= (v_matches r v) a!1))
            :pattern ((In_String v) (v_matches r v))))
       a!15
       a!16
       (forall ((svm (Array String ValueOption))) (= (default svm) NoValue))
       a!17
       a!18
       a!19
       a!20
       a!21
       a!22
       (forall ((ivm (Array Int ValueOption))) (= (default ivm) NoValue))
       a!23
       a!24
       a!25
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (exists ((i Int))
                         (let ((a!1 (< i (of_G_Integer (out_G (v_length v1))))))
                           (and (<= 0 i) a!1 (= (v_nth v1 (v_integer i)) v2))))))
              (= (v_contains v1 v2) (ite a!1 v_tt v_ff)))
            :pattern ((Good_A v1) (v_contains v1 v2))))
       a!26
       a!27
       a!28
       a!29
       a!30
       a!31
       a!32
       a!33
       (= (v_length __dummy_v__) (v_integer 0))
       (= (v_dot __dummy_v__ "test") (v_integer 0))
       (= (v_nth __dummy_v__ __dummy_v__) (v_integer 0))
       (v_has_field __dummy_v__ "test"))))
(assert (let ((a!1 (G_Boolean (and (Good_O response)
                           (v_has_field response "code")
                           (In_Integer (v_dot response "code")))))
      (a!2 (G_Boolean (and (Good_O response)
                           (v_has_field response "header")
                           (Good_O (v_dot response "header")))))
      (a!3 (G_Boolean (and (Good_O ___36)
                           (v_has_field ___36 "code")
                           (In_Integer (v_dot ___36 "code")))))
      (a!4 (G_Boolean (and (Good_O ___36)
                           (v_has_field ___36 "header")
                           (Good_O (v_dot ___36 "header")))))
      (a!6 (and (Good_O ___36)
                (v_has_field ___36 "code")
                (not (Good_R (v_dot ___36 "code"))))))
(let ((a!5 (and (Good_O response)
                (= (O_And (G a!1) (G a!2)) v_tt)
                (Good_O ___36)
                (= (O_And (G a!3) (G a!4)) v_tt)
                (= (O_EQ ___36 response) v_tt))))
  (not (and (=> a!5 a!6))))))

unsat
S:(declare-datatypes ((Value 0)) ((Value (G (out_G General)) (O (out_O SVMap)) (A (out_A IVMap)) (R (id Int) (type String)))))
(declare-datatypes ((General 0)) ((General (G_Boolean (of_G_Boolean Bool)) (G_Integer (of_G_Integer Int)) (G_String (of_G_String String)) (G_Null))))
(declare-datatypes ((ValueOption 0)) ((ValueOption (NoValue) (SomeValue (of_SomeValue Value)))))
(declare-sort IVMap)
(declare-sort SVMap)
(declare-fun v_has_field (Value String) Bool)
(declare-fun __dummy_v__ () Value)
(declare-fun v_integer (Int) Value)
(declare-fun v_nth (Value Value) Value)
(declare-fun v_dot (Value String) Value)
(declare-fun v_length (Value) Value)
(declare-fun ut_expand_simple_string_expansion (Value String) String)
(declare-fun Good_O (Value) Bool)
(declare-fun v_null () Value)
(declare-fun In_String (Value) Bool)
(declare-fun In_Boolean (Value) Bool)
(declare-fun r_resourceidof (Value Value) Value)
(declare-fun v_ff () Value)
(declare-fun Good_R (Value) Bool)
(declare-fun r_representationof (Value Value) Value)
(declare-fun v_contains (Value Value) Value)
(declare-fun Good_A (Value) Bool)
(declare-fun v_tt () Value)
(declare-fun alphai (IVMap) (Array Int ValueOption))
(declare-fun In_Integer (Value) Bool)
(declare-fun betai ((Array Int ValueOption)) IVMap)
(declare-fun alphas (SVMap) (Array String ValueOption))
(declare-fun betas ((Array String ValueOption)) SVMap)
(declare-fun v_matches ((RegEx String) Value) Value)
(declare-fun v_boolean (Bool) Value)
(declare-fun O_++ (Value Value) Value)
(declare-fun v_string (String) Value)
(declare-fun O_LE (Value Value) Value)
(declare-fun O_LT (Value Value) Value)
(declare-fun O_GT (Value Value) Value)
(declare-fun O_GE (Value Value) Value)
(declare-fun O_Or (Value Value) Value)
(declare-fun O_And (Value Value) Value)
(declare-fun O_Minus (Value) Value)
(declare-fun O_Not (Value) Value)
(declare-fun O_NE (Value Value) Value)
(declare-fun O_EQ (Value Value) Value)
(declare-fun O_Mult (Value Value) Value)
(declare-fun O_Sub (Value Value) Value)
(declare-fun O_Sum (Value Value) Value)
(declare-fun O_Implies (Value Value) Value)
(declare-fun O_Equiv (Value Value) Value)
(declare-fun ___38 () Value)
(assert (let ((a!1 (forall ((b Bool))
             (! (= (v_boolean b) (G (G_Boolean b))) :pattern ((v_boolean b)))))
      (a!2 (forall ((i Int))
             (! (= (v_integer i) (G (G_Integer i))) :pattern ((v_integer i)))))
      (a!3 (forall ((s String))
             (! (= (v_string s) (G (G_String s))) :pattern ((v_string s)))))
      (a!4 (forall ((v Value))
             (! (= (In_Boolean v) (and (is-G v) (is-G_Boolean (out_G v))))
                :pattern ((In_Boolean v)))))
      (a!5 (forall ((v Value))
             (! (= (In_Integer v) (and (is-G v) (is-G_Integer (out_G v))))
                :pattern ((In_Integer v)))))
      (a!6 (forall ((v Value))
             (! (= (In_String v) (and (is-G v) (is-G_String (out_G v))))
                :pattern ((In_String v)))))
      (a!7 (forall ((v1 Value) (v2 Value))
             (! (= (O_Equiv v1 v2) (ite (= v1 v2) v_tt v_ff))
                :pattern ((O_Equiv v1 v2)))))
      (a!8 (forall ((v1 Value) (v2 Value))
             (! (= (O_Implies v1 v2) (O_Or (O_Not v1) v2))
                :pattern ((O_Implies v1 v2)))))
      (a!9 (forall ((v1 Value) (v2 Value))
             (! (= (O_EQ v1 v2) (ite (= v1 v2) v_tt v_ff))
                :pattern ((O_EQ v1 v2)))))
      (a!10 (forall ((v1 Value) (v2 Value))
              (! (= (O_NE v1 v2) (ite (= v1 v2) v_ff v_tt))
                 :pattern ((O_NE v1 v2)))))
      (a!11 (forall ((v Value))
              (! (= (O_Not v) (ite (not (= v v_tt)) v_tt v_ff))
                 :pattern ((O_Not v)))))
      (a!12 (forall ((v1 Value) (v2 Value))
              (! (= (O_And v1 v2) (ite (and (= v1 v_tt) (= v2 v_tt)) v_tt v_ff))
                 :pattern ((O_And v1 v2)))))
      (a!13 (forall ((v1 Value) (v2 Value))
              (! (= (O_Or v1 v2) (ite (or (= v1 v_tt) (= v2 v_tt)) v_tt v_ff))
                 :pattern ((O_Or v1 v2)))))
      (a!14 (forall ((v Value))
              (! (let ((a!1 (= (str.len (of_G_String (out_G v)))
                               (of_G_Integer (out_G (v_length v))))))
                   (=> (and (is-G v) (is-G_String (out_G v))) a!1))
                 :pattern ((v_length v)))))
      (a!15 (forall ((am (Array String ValueOption)))
              (= (alphas (betas am)) am)))
      (a!16 (forall ((svm SVMap)) (= (betas (alphas svm)) svm)))
      (a!17 (forall ((l String) (svm SVMap))
              (! (let ((a!1 (not (= (select (alphas svm) l) NoValue))))
                   (= (v_has_field (O svm) l) a!1))
                 :pattern ((v_has_field (O svm) l)))))
      (a!18 (forall ((l String) (svm SVMap))
              (! (= (v_dot (O svm) l) (of_SomeValue (select (alphas svm) l)))
                 :pattern ((v_dot (O svm) l)))))
      (a!19 (forall ((l String) (svm SVMap))
              (! (not (is-R (v_dot (O svm) l))) :pattern ((v_dot (O svm) l)))))
      (a!20 (forall ((v Value) (l String))
              (! (not (= (v_dot v l) v)) :pattern ((v_dot v l)))))
      (a!21 (forall ((am (Array Int ValueOption))) (= (alphai (betai am)) am)))
      (a!22 (forall ((ivm IVMap)) (= (betai (alphai ivm)) ivm)))
      (a!23 (forall ((v Value))
              (let ((a!1 (>= (of_G_Integer (out_G (v_length v))) 0)))
                (and (In_Integer (v_length v)) a!1))))
      (a!24 (forall ((v Value))
              (! (forall ((i Int))
                   (let ((a!1 (< i (of_G_Integer (out_G (v_length v)))))
                         (a!2 (is-SomeValue (select (alphai (out_A v)) i))))
                     (=> (and (<= 0 i) a!1) a!2)))
                 :pattern ((Good_A v)))))
      (a!25 (forall ((v Value) (i Int))
              (! (let ((a!1 (of_SomeValue (select (alphai (out_A v)) i))))
                   (= (v_nth v (v_integer i)) a!1))
                 :pattern ((Good_A v) (v_nth v (v_integer i))))))
      (a!26 (forall ((v1 Value) (v2 Value))
              (! (not (= (v_nth v1 v2) v1)) :pattern ((v_nth v1 v2)))))
      (a!27 (forall ((r1 Value) (r2 Value))
              (! (= (= r1 r2) (= (id r1) (id r2)))
                 :pattern ((Good_R r1) (Good_R r2)))))
      (a!28 (forall ((v Value) (r Value))
              (! (=> (Good_R r) (=> (is-R v) (= (r_representationof v r) v_ff)))
                 :pattern ((r_representationof v r)))))
      (a!29 (forall ((v Value) (r Value))
              (! (=> (Good_R r)
                     (=> (not (In_String v)) (= (r_resourceidof v r) v_ff)))
                 :pattern ((r_resourceidof v r)))))
      (a!30 (forall ((v Value) (k String))
              (! (let ((a!1 (ite (of_G_Boolean (out_G (v_dot v k)))
                                 "true"
                                 "false")))
                   (=> (In_Boolean (v_dot v k))
                       (= (ut_expand_simple_string_expansion v k) a!1)))
                 :pattern ((Good_O v)
                           (v_has_field v k)
                           (ut_expand_simple_string_expansion v k)))))
      (a!31 (forall ((v Value) (k String))
              (! (let ((a!1 (= (ut_expand_simple_string_expansion v k)
                               (of_G_String (out_G (v_dot v k))))))
                   (=> (In_String (v_dot v k)) a!1))
                 :pattern ((Good_O v)
                           (v_has_field v k)
                           (ut_expand_simple_string_expansion v k)))))
      (a!32 (forall ((v Value) (k String))
              (! (=> (= (v_dot v k) v_null)
                     (= (ut_expand_simple_string_expansion v k) ""))
                 :pattern ((Good_O v)
                           (v_has_field v k)
                           (ut_expand_simple_string_expansion v k)))))
      (a!33 (forall ((v Value) (k String))
              (! (=> (not (v_has_field v k))
                     (= (ut_expand_simple_string_expansion v k) ""))
                 :pattern ((Good_O v) (ut_expand_simple_string_expansion v k))))))
  (and (forall ((v Value)) (! (= (Good_A v) (is-A v)) :pattern ((Good_A v))))
       (forall ((v Value)) (! (= (Good_O v) (is-O v)) :pattern ((Good_O v))))
       (forall ((v Value)) (! (= (Good_R v) (is-R v)) :pattern ((Good_R v))))
       (= v_tt (G (G_Boolean true)))
       (= v_ff (G (G_Boolean false)))
       (= v_null (G G_Null))
       a!1
       a!2
       a!3
       a!4
       a!5
       a!6
       a!7
       a!8
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_integer (+ (of_G_Integer (out_G v1))
                                     (of_G_Integer (out_G v2))))))
              (= (O_Sum v1 v2) a!1))
            :pattern ((O_Sum v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_integer (- (of_G_Integer (out_G v1))
                                     (of_G_Integer (out_G v2))))))
              (= (O_Sub v1 v2) a!1))
            :pattern ((O_Sub v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_integer (* (of_G_Integer (out_G v1))
                                     (of_G_Integer (out_G v2))))))
              (= (O_Mult v1 v2) a!1))
            :pattern ((O_Mult v1 v2))))
       a!9
       a!10
       a!11
       (forall ((v Value))
         (! (let ((a!1 (v_integer (- (of_G_Integer (out_G v))))))
              (= (O_Minus v) a!1))
            :pattern ((O_Minus v))))
       a!12
       a!13
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (>= (of_G_Integer (out_G v1))
                                (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_GE v1 v2) a!1))
            :pattern ((O_GE v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (> (of_G_Integer (out_G v1))
                               (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_GT v1 v2) a!1))
            :pattern ((O_GT v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (< (of_G_Integer (out_G v1))
                               (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_LT v1 v2) a!1))
            :pattern ((O_LT v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (<= (of_G_Integer (out_G v1))
                                (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_LE v1 v2) a!1))
            :pattern ((O_LE v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_string (str.++ (of_G_String (out_G v1))
                                         (of_G_String (out_G v2))))))
              (= (O_++ v1 v2) a!1))
            :pattern ((O_++ v1 v2))))
       a!14
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (str.contains (of_G_String (out_G v1))
                                          (of_G_String (out_G v2)))
                            v_tt
                            v_ff)))
              (= (v_contains v1 v2) a!1))
            :pattern ((In_String v1) (In_String v2) (v_contains v1 v2))))
       (forall ((r (RegEx String)) (v Value))
         (! (let ((a!1 (v_boolean (str.in.re (of_G_String (out_G v)) r))))
              (= (v_matches r v) a!1))
            :pattern ((In_String v) (v_matches r v))))
       a!15
       a!16
       (forall ((svm (Array String ValueOption))) (= (default svm) NoValue))
       a!17
       a!18
       a!19
       a!20
       a!21
       a!22
       (forall ((ivm (Array Int ValueOption))) (= (default ivm) NoValue))
       a!23
       a!24
       a!25
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (exists ((i Int))
                         (let ((a!1 (< i (of_G_Integer (out_G (v_length v1))))))
                           (and (<= 0 i) a!1 (= (v_nth v1 (v_integer i)) v2))))))
              (= (v_contains v1 v2) (ite a!1 v_tt v_ff)))
            :pattern ((Good_A v1) (v_contains v1 v2))))
       a!26
       a!27
       a!28
       a!29
       a!30
       a!31
       a!32
       a!33
       (= (v_length __dummy_v__) (v_integer 0))
       (= (v_dot __dummy_v__ "test") (v_integer 0))
       (= (v_nth __dummy_v__ __dummy_v__) (v_integer 0))
       (v_has_field __dummy_v__ "test"))))
(assert (let ((a!1 (G_Boolean (= ___38 (G (G_Integer 201))))))
(let ((a!2 (=> (and true (In_Integer ___38) (= (G a!1) v_tt))
               (not (Good_R ___38)))))
  (not (and a!2)))))

unsat
S:(declare-datatypes ((Value 0)) ((Value (G (out_G General)) (O (out_O SVMap)) (A (out_A IVMap)) (R (id Int) (type String)))))
(declare-datatypes ((General 0)) ((General (G_Boolean (of_G_Boolean Bool)) (G_Integer (of_G_Integer Int)) (G_String (of_G_String String)) (G_Null))))
(declare-datatypes ((ValueOption 0)) ((ValueOption (NoValue) (SomeValue (of_SomeValue Value)))))
(declare-sort IVMap)
(declare-sort SVMap)
(declare-fun v_has_field (Value String) Bool)
(declare-fun __dummy_v__ () Value)
(declare-fun v_integer (Int) Value)
(declare-fun v_nth (Value Value) Value)
(declare-fun v_dot (Value String) Value)
(declare-fun v_length (Value) Value)
(declare-fun ut_expand_simple_string_expansion (Value String) String)
(declare-fun Good_O (Value) Bool)
(declare-fun v_null () Value)
(declare-fun In_String (Value) Bool)
(declare-fun In_Boolean (Value) Bool)
(declare-fun r_resourceidof (Value Value) Value)
(declare-fun v_ff () Value)
(declare-fun Good_R (Value) Bool)
(declare-fun r_representationof (Value Value) Value)
(declare-fun v_contains (Value Value) Value)
(declare-fun Good_A (Value) Bool)
(declare-fun v_tt () Value)
(declare-fun alphai (IVMap) (Array Int ValueOption))
(declare-fun In_Integer (Value) Bool)
(declare-fun betai ((Array Int ValueOption)) IVMap)
(declare-fun alphas (SVMap) (Array String ValueOption))
(declare-fun betas ((Array String ValueOption)) SVMap)
(declare-fun v_matches ((RegEx String) Value) Value)
(declare-fun v_boolean (Bool) Value)
(declare-fun O_++ (Value Value) Value)
(declare-fun v_string (String) Value)
(declare-fun O_LE (Value Value) Value)
(declare-fun O_LT (Value Value) Value)
(declare-fun O_GT (Value Value) Value)
(declare-fun O_GE (Value Value) Value)
(declare-fun O_Or (Value Value) Value)
(declare-fun O_And (Value Value) Value)
(declare-fun O_Minus (Value) Value)
(declare-fun O_Not (Value) Value)
(declare-fun O_NE (Value Value) Value)
(declare-fun O_EQ (Value Value) Value)
(declare-fun O_Mult (Value Value) Value)
(declare-fun O_Sub (Value Value) Value)
(declare-fun O_Sum (Value Value) Value)
(declare-fun O_Implies (Value Value) Value)
(declare-fun O_Equiv (Value Value) Value)
(declare-fun ___40 () Value)
(declare-fun response () Value)
(assert (let ((a!1 (forall ((b Bool))
             (! (= (v_boolean b) (G (G_Boolean b))) :pattern ((v_boolean b)))))
      (a!2 (forall ((i Int))
             (! (= (v_integer i) (G (G_Integer i))) :pattern ((v_integer i)))))
      (a!3 (forall ((s String))
             (! (= (v_string s) (G (G_String s))) :pattern ((v_string s)))))
      (a!4 (forall ((v Value))
             (! (= (In_Boolean v) (and (is-G v) (is-G_Boolean (out_G v))))
                :pattern ((In_Boolean v)))))
      (a!5 (forall ((v Value))
             (! (= (In_Integer v) (and (is-G v) (is-G_Integer (out_G v))))
                :pattern ((In_Integer v)))))
      (a!6 (forall ((v Value))
             (! (= (In_String v) (and (is-G v) (is-G_String (out_G v))))
                :pattern ((In_String v)))))
      (a!7 (forall ((v1 Value) (v2 Value))
             (! (= (O_Equiv v1 v2) (ite (= v1 v2) v_tt v_ff))
                :pattern ((O_Equiv v1 v2)))))
      (a!8 (forall ((v1 Value) (v2 Value))
             (! (= (O_Implies v1 v2) (O_Or (O_Not v1) v2))
                :pattern ((O_Implies v1 v2)))))
      (a!9 (forall ((v1 Value) (v2 Value))
             (! (= (O_EQ v1 v2) (ite (= v1 v2) v_tt v_ff))
                :pattern ((O_EQ v1 v2)))))
      (a!10 (forall ((v1 Value) (v2 Value))
              (! (= (O_NE v1 v2) (ite (= v1 v2) v_ff v_tt))
                 :pattern ((O_NE v1 v2)))))
      (a!11 (forall ((v Value))
              (! (= (O_Not v) (ite (not (= v v_tt)) v_tt v_ff))
                 :pattern ((O_Not v)))))
      (a!12 (forall ((v1 Value) (v2 Value))
              (! (= (O_And v1 v2) (ite (and (= v1 v_tt) (= v2 v_tt)) v_tt v_ff))
                 :pattern ((O_And v1 v2)))))
      (a!13 (forall ((v1 Value) (v2 Value))
              (! (= (O_Or v1 v2) (ite (or (= v1 v_tt) (= v2 v_tt)) v_tt v_ff))
                 :pattern ((O_Or v1 v2)))))
      (a!14 (forall ((v Value))
              (! (let ((a!1 (= (str.len (of_G_String (out_G v)))
                               (of_G_Integer (out_G (v_length v))))))
                   (=> (and (is-G v) (is-G_String (out_G v))) a!1))
                 :pattern ((v_length v)))))
      (a!15 (forall ((am (Array String ValueOption)))
              (= (alphas (betas am)) am)))
      (a!16 (forall ((svm SVMap)) (= (betas (alphas svm)) svm)))
      (a!17 (forall ((l String) (svm SVMap))
              (! (let ((a!1 (not (= (select (alphas svm) l) NoValue))))
                   (= (v_has_field (O svm) l) a!1))
                 :pattern ((v_has_field (O svm) l)))))
      (a!18 (forall ((l String) (svm SVMap))
              (! (= (v_dot (O svm) l) (of_SomeValue (select (alphas svm) l)))
                 :pattern ((v_dot (O svm) l)))))
      (a!19 (forall ((l String) (svm SVMap))
              (! (not (is-R (v_dot (O svm) l))) :pattern ((v_dot (O svm) l)))))
      (a!20 (forall ((v Value) (l String))
              (! (not (= (v_dot v l) v)) :pattern ((v_dot v l)))))
      (a!21 (forall ((am (Array Int ValueOption))) (= (alphai (betai am)) am)))
      (a!22 (forall ((ivm IVMap)) (= (betai (alphai ivm)) ivm)))
      (a!23 (forall ((v Value))
              (let ((a!1 (>= (of_G_Integer (out_G (v_length v))) 0)))
                (and (In_Integer (v_length v)) a!1))))
      (a!24 (forall ((v Value))
              (! (forall ((i Int))
                   (let ((a!1 (< i (of_G_Integer (out_G (v_length v)))))
                         (a!2 (is-SomeValue (select (alphai (out_A v)) i))))
                     (=> (and (<= 0 i) a!1) a!2)))
                 :pattern ((Good_A v)))))
      (a!25 (forall ((v Value) (i Int))
              (! (let ((a!1 (of_SomeValue (select (alphai (out_A v)) i))))
                   (= (v_nth v (v_integer i)) a!1))
                 :pattern ((Good_A v) (v_nth v (v_integer i))))))
      (a!26 (forall ((v1 Value) (v2 Value))
              (! (not (= (v_nth v1 v2) v1)) :pattern ((v_nth v1 v2)))))
      (a!27 (forall ((r1 Value) (r2 Value))
              (! (= (= r1 r2) (= (id r1) (id r2)))
                 :pattern ((Good_R r1) (Good_R r2)))))
      (a!28 (forall ((v Value) (r Value))
              (! (=> (Good_R r) (=> (is-R v) (= (r_representationof v r) v_ff)))
                 :pattern ((r_representationof v r)))))
      (a!29 (forall ((v Value) (r Value))
              (! (=> (Good_R r)
                     (=> (not (In_String v)) (= (r_resourceidof v r) v_ff)))
                 :pattern ((r_resourceidof v r)))))
      (a!30 (forall ((v Value) (k String))
              (! (let ((a!1 (ite (of_G_Boolean (out_G (v_dot v k)))
                                 "true"
                                 "false")))
                   (=> (In_Boolean (v_dot v k))
                       (= (ut_expand_simple_string_expansion v k) a!1)))
                 :pattern ((Good_O v)
                           (v_has_field v k)
                           (ut_expand_simple_string_expansion v k)))))
      (a!31 (forall ((v Value) (k String))
              (! (let ((a!1 (= (ut_expand_simple_string_expansion v k)
                               (of_G_String (out_G (v_dot v k))))))
                   (=> (In_String (v_dot v k)) a!1))
                 :pattern ((Good_O v)
                           (v_has_field v k)
                           (ut_expand_simple_string_expansion v k)))))
      (a!32 (forall ((v Value) (k String))
              (! (=> (= (v_dot v k) v_null)
                     (= (ut_expand_simple_string_expansion v k) ""))
                 :pattern ((Good_O v)
                           (v_has_field v k)
                           (ut_expand_simple_string_expansion v k)))))
      (a!33 (forall ((v Value) (k String))
              (! (=> (not (v_has_field v k))
                     (= (ut_expand_simple_string_expansion v k) ""))
                 :pattern ((Good_O v) (ut_expand_simple_string_expansion v k))))))
  (and (forall ((v Value)) (! (= (Good_A v) (is-A v)) :pattern ((Good_A v))))
       (forall ((v Value)) (! (= (Good_O v) (is-O v)) :pattern ((Good_O v))))
       (forall ((v Value)) (! (= (Good_R v) (is-R v)) :pattern ((Good_R v))))
       (= v_tt (G (G_Boolean true)))
       (= v_ff (G (G_Boolean false)))
       (= v_null (G G_Null))
       a!1
       a!2
       a!3
       a!4
       a!5
       a!6
       a!7
       a!8
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_integer (+ (of_G_Integer (out_G v1))
                                     (of_G_Integer (out_G v2))))))
              (= (O_Sum v1 v2) a!1))
            :pattern ((O_Sum v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_integer (- (of_G_Integer (out_G v1))
                                     (of_G_Integer (out_G v2))))))
              (= (O_Sub v1 v2) a!1))
            :pattern ((O_Sub v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_integer (* (of_G_Integer (out_G v1))
                                     (of_G_Integer (out_G v2))))))
              (= (O_Mult v1 v2) a!1))
            :pattern ((O_Mult v1 v2))))
       a!9
       a!10
       a!11
       (forall ((v Value))
         (! (let ((a!1 (v_integer (- (of_G_Integer (out_G v))))))
              (= (O_Minus v) a!1))
            :pattern ((O_Minus v))))
       a!12
       a!13
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (>= (of_G_Integer (out_G v1))
                                (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_GE v1 v2) a!1))
            :pattern ((O_GE v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (> (of_G_Integer (out_G v1))
                               (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_GT v1 v2) a!1))
            :pattern ((O_GT v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (< (of_G_Integer (out_G v1))
                               (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_LT v1 v2) a!1))
            :pattern ((O_LT v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (<= (of_G_Integer (out_G v1))
                                (of_G_Integer (out_G v2)))
                            v_tt
                            v_ff)))
              (= (O_LE v1 v2) a!1))
            :pattern ((O_LE v1 v2))))
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (v_string (str.++ (of_G_String (out_G v1))
                                         (of_G_String (out_G v2))))))
              (= (O_++ v1 v2) a!1))
            :pattern ((O_++ v1 v2))))
       a!14
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (ite (str.contains (of_G_String (out_G v1))
                                          (of_G_String (out_G v2)))
                            v_tt
                            v_ff)))
              (= (v_contains v1 v2) a!1))
            :pattern ((In_String v1) (In_String v2) (v_contains v1 v2))))
       (forall ((r (RegEx String)) (v Value))
         (! (let ((a!1 (v_boolean (str.in.re (of_G_String (out_G v)) r))))
              (= (v_matches r v) a!1))
            :pattern ((In_String v) (v_matches r v))))
       a!15
       a!16
       (forall ((svm (Array String ValueOption))) (= (default svm) NoValue))
       a!17
       a!18
       a!19
       a!20
       a!21
       a!22
       (forall ((ivm (Array Int ValueOption))) (= (default ivm) NoValue))
       a!23
       a!24
       a!25
       (forall ((v1 Value) (v2 Value))
         (! (let ((a!1 (exists ((i Int))
                         (let ((a!1 (< i (of_G_Integer (out_G (v_length v1))))))
                           (and (<= 0 i) a!1 (= (v_nth v1 (v_integer i)) v2))))))
              (= (v_contains v1 v2) (ite a!1 v_tt v_ff)))
            :pattern ((Good_A v1) (v_contains v1 v2))))
       a!26
       a!27
       a!28
       a!29
       a!30
       a!31
       a!32
       a!33
       (= (v_length __dummy_v__) (v_integer 0))
       (= (v_dot __dummy_v__ "test") (v_integer 0))
       (= (v_nth __dummy_v__ __dummy_v__) (v_integer 0))
       (v_has_field __dummy_v__ "test"))))
(assert (let ((a!1 (G_Boolean (and (Good_O response)
                           (v_has_field response "code")
                           (In_Integer (v_dot response "code")))))
      (a!2 (G_Boolean (and (Good_O response)
                           (v_has_field response "header")
                           (Good_O (v_dot response "header")))))
      (a!3 (G_Boolean (= (v_dot response "code") (G (G_Integer 201))))))
(let ((a!4 (and (Good_O response)
                (= (O_And (G a!1) (G a!2)) v_tt)
                (In_Boolean ___40)
                (= (O_EQ ___40 (G a!3)) v_tt))))
  (not (and (=> a!4 (In_Boolean ___40)))))))

unsat
01:08:39.960 [main] DEBUG VALIDATION STATISTICS - Total duration of validation: 791ms
01:08:39.961 [main] DEBUG VALIDATION STATISTICS - Number of subtyping checks: 9
01:08:39.961 [main] DEBUG VALIDATION STATISTICS - Number of semantic subtyping checks: 9
01:08:39.961 [main] DEBUG VALIDATION STATISTICS - Number of cache hits during semantic subtyping checks: 0
01:08:39.961 [main] DEBUG VALIDATION STATISTICS - Number of cache misses during semantic subtyping checks: 9
01:08:39.961 [main] DEBUG VALIDATION STATISTICS - Total duration of semantic subtyping checks: 545ms
01:08:39.964 [main] DEBUG VALIDATION STATISTICS - Average duration per semantic subtyping check: 60.55555555555556ms
01:08:39.965 [main] DEBUG VALIDATION STATISTICS - Total duration of semantic subtyping checks (only cache misses): 545ms
01:08:39.965 [main] DEBUG VALIDATION STATISTICS - Average duration per semantic subtyping check (only cache misses): 60.55555555555556ms
01:08:39.965 [main] DEBUG VALIDATION STATISTICS - Number of non conclusive semantic subtyping checks (warnings): 0
Spec: Erro, errors: 1
01:08:39.966 [main] ERROR HeadREST - Invalid specification!
01:08:39.972 [main] ERROR HeadREST - Failed semantic checking:
- Diagnostic ERROR code=validator "Expression synthesizes type [c : Contact] when it was expected to be a subtype of {id: any}, with environment: 
{
	request: (___2 : {} where ((___2 in {location: string}) && (___2 in {template: {}}) && (___2 in {header: {}})))
	root: URI
	___7: (_ : any where (request in {body: integer}))
	c: Contact
}" at RSpec'Erro'.axioms[0]->Axiom.precondition->AxiomBlock'{'.expression->Conjunction.right->SimpleQuantifier.expr->Equality.left->ObjectPropertyAccess.object->ProgramVariableRef [line #9, column #23]

